<html>
  <head>
    <meta charset="utf-8">
    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="Lessons ATOM Feed">
    <link href="reset.css" rel="stylesheet" type="text/css">
    <link href="base.css" rel="stylesheet" type="text/css">
    <title>
      D3, Conceptually - Lesson 2
    </title>
    <script type="text/javascript" src="d3.v2.min.js"></script>
    <script type="text/javascript" src="base.js"></script>
    <script type="text/javascript" src="beautify-html.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24357809-1']);
      _gaq.push(['_setDomainName', 'hazzens.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class='header'>
      <div class='left-bar'>
      </div>
      <div class='content'>
        <h1 id='masthead'>
          D3, Conceptually
        </h1>
        <h2 class='lesson'>
          Lesson 2: Charts <span class='warn'>UNDER CONSTRUCTION</span>
        </h2>
      </div>
    </div>
    <div class='main'>
      <div class='left-bar'>
        <h2 class='border-bottom'>index</h2>
        <ul class='pad-top selector'>
          <li><a href='lesson_0.html'>0. Preface</a></li>
          <li><a href='lesson_1.html'>1. Introductory elements</a></li>
          <li class='selected'><a href='lesson_2.html'>2. Charts</a></li>
        </ul>
      </div>
      <div class='content'>
        <div class='section'>
          <div class='section-header' id='s1'>
            2.1 Making some charts outside of the school
          </div>
          <div class='section-content'>
            We start this lesson with a simple (and completely contrived)
            problem to solve. Word has it the world might be ending; some
            aliens have contacted the leader of the world (pretend, will you)
            and demanded they be shown a bar chart of the even numbers up to 10.
            Some sort of test, we gather, and if we can't deliver they promise
            to destroy the world. A far-fetched request, but it sure beats a
            whale.
            <hr>
            So, how to begin? As everything, with our data:
            <code class='block js'>var evenNumbers = [0, 2, 4, 6, 8, 10];</code>
            Good, good. Now, the aliens also demanded the graph have a width
            of 600 pixels and height of 100&mdash;those numbers please them
            (don't ask how they share our definition of pixels). Putting those
            in variables won't hurt:
            <code class='block js'>var width = 600;
var height = 100;</code>
            And why not arbitrarily decide the bars will be stacked vertically,
            each extending to the right in proportion to the represented number.
            So, if we have six bars, that must make each of them
            <code class='js'>height / 6</code> pixels tall. Hardcoding
            <code class='js'>6</code> doesn't really strike me as a good idea,
            considering the example we set above. So, we make sure
            however many bars we have will fit:
            <code class='block js'>var barHeight = height / evenNumbers.length;</code>
            What about the width of each bar? Well, that depends on the number
            it represents. We have 600 pixels to work with; giving 10, the
            largest datum, a width of 600 pixels will work fine (and zero,
            obviously, gets zero). A function for that would be:
            <code class='block js'>var barWidth = function(number) {
  return number * (width / 10);
};</code>
            "Aha!", you might say, "shouldn't that <em>also</em> vary based
            on the data, and not hard-coded? Aren't you setting a bad example
            for the kids?". And I would reply with a proper function:
            <code class='block js'>var maxDataValue = d3.max(evenNumbers);
var barWidth = function(number) {
  return number * (width / maxDataValue);
};</code>
            A <code class>rect</code> element in SVG is defined by its
            <code>width</code>, <code>height</code>, <code>x</code>, and
            <code>y</code> attributes. We have two of them
            <span class='nobr'>(<code class='html'>width</code></span>
            and <code>height</code>), so lets get the others.
            <div class='aside'>
              Remember, in SVG the top-left corner is (0, 0). x-coordinates
              increase to the right and y-coordinates increase down the page.
            </div>
            <code>x</code> is quite easy, actually. All bars should
            be aligned along the left axis, so they all have an <code>x</code>
            of 0. <code>y</code> takes a <em>bit</em> more thought, but not
            much (save those brain cells for something else). The
            <code>i</code>-th even number should be offset by <code>i * barHeight</code>.
            Or, in a function:
            <code class='block js'>var barY = function(index) {
  return index * barHeight;
};</code>
            Now, we know from the <a href='lesson_1.html#s5'>last lesson</a>
            that <code>barY</code> is probably
            going to be provided as an argument to <code>attr</code>, and when
            a function is provided to <code>attr</code> it gets two arguments:
            first the <code>datum</code>, then the <code>index</code>.
            So we change the function to:
            <code class='block js'>var barY = function(datum, index) {
  return index * barHeight;
};</code>
            Putting all of this together, and choosing arbitrary colors, we get:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = 100;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('border', '1px solid black');

var evenNumbers = [0, 2, 4, 6, 8, 10];
var maxDataValue = d3.max(evenNumbers);
var barHeight = height / evenNumbers.length;
var barWidth = function(datum) {
  return datum * (width / maxDataValue);
};
var barX = 0;
var barY = function(datum, index) {
  return index * barHeight;
};
root.selectAll('rect.number')
    .data(evenNumbers).enter()
  .append('rect')
    .attr({
      'class': 'number',
      'x': barX,
      'y': barY,
      'width': barWidth,
      'height': barHeight,
      'fill': '#dff',
      'stroke': '#444',
    });</code>
              <code class='block result'></code>
            </div>
            <div class='aside'>
               New syntax! Join the club. D3 is under
               <a href='https://github.com/mbostock/d3/wiki/Release-Notes'>constant
               development</a> and new features get added with some frequency.
               Your author tries to keep up, but can't always be bothered.
               Hopefully you pick better role models. Passing a map to the
               <code>attr</code> function (among others) is shorthand for
               calling <code>attr</code> for each (key, value) pair in the map.
             </div>
             <hr>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s2'>
            2.3 A bigger palette
          </div>
          <div class='section-content'>
            Contrary to the example we've set, SVG provides more primitives than
            the lowly <code>rect</code>. And you know what that means: more
            contrived examples. Let's consider a new graph - a self-descriptive
            <!-- TODO link me --> one. A plot of cicles, where the x-axis is
            the radius of the circle and the y-axis is the number of pixels
            in that circle (its area).
            <hr>
            The <code>circle</code><!--TODO--> element is just what we need.
            Like the <code>rect</code> before it, and all the future SVG
            elements we render, it supports presentation attributes.
            <div class='aside'>
              Huh? What?  Afraid you fell asleep in class and missed the
              definition of the word? Nope, the teacher is just making you
              sweat. The presentation attributes <!--LINK--> are the attributes
              that determine how a shape is rendered. We've already seen
              <code>fill</code> and <code>stroke</code>. There are more to come,
              but we won't be exhaustive. The SVG standard is, while not exactly
              readable, easy to browse and full of examples. Consider browsing
              it over coffee. Or not, actually. Don't do that.
            </div>
            While the presentation of a <code>circle</code> is the same as a
            <code>rect</code>, the positioning isn't. We need three attributes:
            The <code>circle</code> is centered at
            <span class='nobr'>(<code>cx</code>,</span>
            <code>cy</code>) and has a radius of <code>r</code>. So, building it
            much like the last one with a few changes:
            <code class='block js'>var circleX = function(radius) { return radius; };
var circleY = function(radius) { return Math.PI * radius * radius; };</code>
            We'll also, obviously, need a larger area to render our circles in.
            Let's try radius values of <code>[1, 2, 3, 5]</code>.
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = 100;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('background', 'white');

var circleRs = [1, 2, 3, 5];
var circleX = function(radius) { return radius; };
var circleY = function(radius) { return Math.PI * radius * radius; };
var circleR = function(radius) { return radius; };

root.selectAll('circle')
    .data(circleRs).enter()
  .append('circle')
    .attr({
        'cx': circleX,
        'cy': circleY,
        'r': circleR,
        'fill': '#ffcdcd',
        'stroke': '#666',
    });</code>
              <code class='block result'></code>
            </div>
            Hrm, not the best graph. We have a few obvious issues: first, 100
            pixels of height is not going to cut it at this scale if we want to
            have larger circles. Second, our elements are scrunched along the
            left. Thirdly, our y-axis is <em>reversed</em> from a normal graph.
            The third is easy to solve - instead of mapping the
            <code>radius</code> to <code>Math.PI * radius * radius</code>, we
            instead subtract that value from the height of the graph:
            <code>height - Math.PI * radius * radius</code>. The first two are
            both classes of the same problem - a scale where 1 unit along the
            axis is 1 pixel is tiny. Miniscule. Laughable. Infintesimal. No,
            wait, that isn't right. Got carried away with my adjectives.
            <hr>
            When drawing a graph on paper, your scale is more likely to be
            closer to 10mm to 1 unit (we don't use imperial units here; those
            despots will never keep us down). We can fix that by scaling our
            computed <code>cx</code> and <code>cy</code> values by an arbitrary
            number - <code>4</code> sounds good. We'll also need to change our
            bounds; if the largest circle is has a radius of <code>5</code>, we
            would like <code>height - 4 * Math.PI * 5 * 5</code> to not be
            negative; 350 is big enough for that. Now, our new (and maybe
            improved) chart:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = <em>350</em>;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('background', 'white');

var circleRs = [1, 2, 3, 5];
var circleX = function(radius) { return <em>4 *</em> radius; };
var circleY = function(radius) { return <em>height - 4 *</em> Math.PI * radius * radius; };
var circleR = function(radius) { return radius; };

root.selectAll('circle')
    .data(circleRs).enter()
  .append('circle')
    .attr({
        'cx': circleX,
        'cy': circleY,
        'r': circleR,
        'fill': '#ffcdcd',
        'stroke': '#666',
    });</code>
              <code class='block result'></code>
            </div>
            In the tradition of all my favorite textbooks, I leave deciding if
            that is an improvement as an exercise for the reader.
            <span class='spoiler'>It really isn't much of an improvement. Not
            much could save the chart, really. Terribly dreadful, that.</span>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s3'>
            2.3 Tipping the scales
          </div>
          <div class='section-content'>
            While the previous example wasn't bad code, it isn't exactly
            idiomatic D3. It works, but D3 provides many helpers <!-- TODO link
            me --!> to make our code easier to read and our intent clear. For
            example, <span class='nobr'><code>d3.scale</code>.</span><!--TODO-->
            You may have noticed in the last example we had inserted some magic
            values in our attribute functions (like <code>4</code> and
            <code>height</code>). But these were <em>separate</em> from the data
            we actually cared about - that our <code>cx</code> is just the
            <code>radius</code> on some arbitrary scale, and the <code>cy</code>
            is likewise a <em>number</em> on some <em>scale</em>. In case the
            name, and this hammering of a point, did not clue you in,
            <code>d3.scale</code> and its many members are designed to assist
            us.
            <hr>
            Before we introduce our first scale, we'll define what a scale
            <em>is</em>. A scale is a function that maps input values to output
            values. Neither the input nor output need be numbers, but starting
            with them will be easiest. The simplest scale, then, is the identity
            function. We used that, implicitly, in the first circle example (the
            "bad" one). We mapped our data (radius) values to a value along some
            axis, then scaled that axis using the identity function.
            <hr>
            In the second, questionably improved, example, we scaled that axis
            by multipling by 4. Our scale function was then <code>function(x) {
              return 4 * x; };</code>. This is an example of a
            <em>linear scale</em> (as, an astute reader will note, is the
            identity scale). D3 provides <code>d3.scale.linear</code> for just
            this purpose.
            <hr>
            The <a href='https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear'>
              documentation</a> for it is useful, but you can save the for
            later. The short of it is thus: <code>d3.scale.linear()</code>
            returns a new <code>object</code> that is <em>also</em> a
            <code>function</code>. The two methods of current interest on the
            object are <code>domain</code> and <code>range</code>. Both take an
            array of values that specify, respectively, the <em>domain</em> and
            <em>range</em> of the scale function. An example would prove
            instructive:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root');
var scale = d3.scale.linear()
    .domain([0, 10])
    .range([0, 100]);

root.selectAll('div')
    .data([0, 10, 5, -5, 100]).enter()
  .append('div')
    .text(function(d) {
      return 'The scaled value of ' + d + ' is ' + scale(d);
    });</code>
              <code class='block result'></code>
            </div>
            The first two lines are, hopefully, exactly as expected - an input
            of <code>0</code> (the first element of the domain) maps to an
            output of <code>0</code> (the first element of the range), just as
            <code>10</code> maps to <code>100</code>. The third value,
            <code>5</code> should also make sense - our scale is linear, so an
            input value halfway between the domain values of <code>0</code> and
            <code>10</code> maps to an output value halfway between the
            respective range values&mdash;<code>0</code> and <code>100</code>.
            <hr>
            The other two may be surprising, but follow from above. If an input
            value falls outside the domain, the scale pretends the domain and
            range are extended to include the value. If you don't like this
            behavior, you can call <code>.clamp(true)</code> on the scale to
            force all values to fall within the domain.
            <div class='aside'>
              Linear scales actually accept an array length <em>at least</em> 2
              for the domain and range.  This is a more advanced feature which
              may prove useful later, but for now only serves to confuse. Read
              the <a
                href='https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_domain'>docs</a>
              or attempt to guess the semantics if you want, or just carry on
              with your life. All are valid paths, and one may find
              enlightenment along any.
            </div>
            We can use our scalar powers (sweet! only a Levenshtein distance of
            4 from super!) to improve the second circle example. Now, we have a
            lot of options available to us - <em>anything</em> that results in
            <code>1</code> mapping to <code>4</code> will work. So what values
            to use for the domain and range? Why not the simplest - a domain of
            <code>[0, 1]</code> and a range of <code>[0, 4]</code>.
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = 350;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('background', 'white');

var circleRs = [1, 2, 3, 5];
<em>var xScale = d3.scale.linear()
    .domain([0, 1])
    .range([0, 4]);
var yScale = xScale;  // Our x and y use the same scale.
var circleX = function(radius) { return xScale(radius); };
var circleY = function(radius) { return height - yScale(Math.PI * radius * radius); };</em>
var circleR = function(radius) { return radius; };

root.selectAll('circle')
    .data(circleRs).enter()
  .append('circle')
    .attr({
        'cx': circleX,
        'cy': circleY,
        'r': circleR,
        'fill': '#ffcdcd',
        'stroke': '#666',
    });</code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s4'>
            2.4 Nope, sorry, that circles example is still rubbish
          </div>
          <div class='section-content'>
            And I'm not going to let it rest until that code is <em>good</em>
            (even if the source of the chart is contrived). The <code>yScale</code>
            used in the example is, frankly, an embarassment. Look at our
            <code>circleY</code> function again:
            <code class='block js'>var circleY = function(radius) { return height - yScale(Math.PI * radius * radius); };</code>
            We still have parts of our conversion from axis to pixels (our
            original motivation for scales) <em>outside</em> of the scale
            definition. I'm speaking, of course, of that pesky <code>height
              -</code> that begins our function. So, to fix it, we need to put
            on our thinking caps.
            <hr>
            We need two input values and two output values for a scale. We have
            a trivially easy one - the input value of <code>0</code> maps to the
            output value of <code>height</code>. That was fun! Plug and play
            sure is easier than Windows 95 led me to believe... and we can just
            put in another input value to get another output value.
            <hr>
            But <em>what</em> input value? We can choose one arbitrarily and it
            will just work. Why not <code>1</code>, which maps to <code>height -
              4 * Math.PI * 1 * 1</code> or simply
            <code>337.4336blahblahblah</code>. Or actually simpler in the form
            of <code>height - 4 * Math.PI</code>. So we just put that in our code,
            right? Problem solved?
            <code class='block js'>var scaleY = d3.scale.linear()
    .domain([0, 1])
    .range([height, height - 4 * Math.PI]);</code>
            No! Wrong! Bad student! I'd hit you with my newspaper, but I can't
            find one - think they all went out of business. The only thing we've
            accomplished is moving a magic number from one place to another. Why
            not try again - why are we subtracting <code>4 * Math.PI</code> from
            <code>height</code>?
          </div>
        </div>
      </div>
    </div>
    <div class='footer'>
      <div class='content'>
        Copyright 2012 <a href='http://hazzens.com'>Mikey Levine</a>
        &mdash; <a href='atom.xml'>New Lesson Feed</a>
        <div class='float-right'>
          Built using <a href='http://d3js.org'>D3</a> and
          <a href='https://github.com/einars/js-beautify'>js-beautify</a>
        </div>
      </div>
    </div>
  </body>
  <script type="text/javascript">
    tut.init();
  </script>
</html>
