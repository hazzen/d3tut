<html>
  <head>
    <meta charset="utf-8">
    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="Lessons ATOM Feed">
    <link href="reset.css" rel="stylesheet" type="text/css">
    <link href="base.css" rel="stylesheet" type="text/css">
    <title>
      D3, Conceptually - Lesson 2
    </title>
    <script type="text/javascript" src="d3.v2.min.js"></script>
    <script type="text/javascript" src="base.js"></script>
    <script type="text/javascript" src="beautify-html.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24357809-1']);
      _gaq.push(['_setDomainName', 'hazzens.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class='header'>
      <div class='left-bar'>
      </div>
      <div class='content'>
        <h1 id='masthead'>
          D3, Conceptually
        </h1>
        <h2 class='lesson'>
          Lesson 2: Charts
        </h2>
      </div>
    </div>
    <div class='main'>
      <div class='left-bar'>
        <h2 class='border-bottom'>index</h2>
        <ul class='pad-top selector'>
          <li><a href='lesson_0.html'>0. Preface</a></li>
          <li><a href='lesson_1.html'>1. Introductory elements</a></li>
          <li class='selected'><a href='lesson_2.html'>2. Charts</a></li>
        </ul>
      </div>
      <div class='content'>
        <div class='section'>
          <div class='section-header' id='s1'>
            2.1 Making some charts outside of the school
          </div>
          <div class='section-content'>
            We start this lesson with a simple (and completely contrived)
            problem to solve. Word has it the world might be ending; some
            aliens have contacted the leader of the world (pretend, will you)
            and demanded to be shown a bar chart of the even numbers up to 10.
            Some sort of test, we gather. If we can't deliver, they promise
            to destroy the world. A far-fetched request, but it sure beats a
            whale. Really, who wants a whale?
            <hr>
            So, how to begin? As everything, with our data:
            <code class='block js'>var evenNumbers = [0, 2, 4, 6, 8, 10];</code>
            Good, good. Now, the aliens also demanded the graph have a width
            of 600 pixels and height of 100&mdash;those numbers please them
            (don't ask how they share our definition of pixels). Putting those
            in variables won't hurt:
            <code class='block js'>var width = 600;
var height = 100;</code>
            And why not arbitrarily decide the bars will be stacked vertically,
            each extending to the right in proportion to the represented
            number. And we'll use the full 600x100 pixels. If we have six
            bars, that must make each of them
            <code class='js'>height / 6</code> pixels tall. Hardcoding
            <code class='js'>6</code> doesn't really strike me as a good idea,
            considering the example we set above. Plus, the aliens might want more
            numbers in the future. Insteand, we make sure however many bars we
            have will fit:
            <code class='block js'>var barHeight = height / evenNumbers.length;</code>
            What about the width of each bar? Well, that depends on the number
            it represents. We have 600 pixels to work with; giving 10, the
            largest datum, a width of 600 pixels will work fine (and zero,
            obviously, gets zero). A function for that would be:
            <code class='block js'>var barWidth = function(number) {
  return number * (width / 10);
};</code>
            "Aha!", you might say, "shouldn't that <em>also</em> vary based
            on the data, and not hard-coded? Aren't you setting a bad example
            for the kids?". And I would reply with a proper function (and,
            possibly, a not-so-proper gesture):
            <code class='block js'>var maxDataValue = d3.max(evenNumbers);
var barWidth = function(number) {
  return number * (width / maxDataValue);
};</code>
            A <code class>rect</code> element in SVG is defined by its
            <code>width</code>, <code>height</code>, <code>x</code>, and
            <code>y</code> attributes. We have two of them
            <span class='nobr'>(<code class='html'>width</code></span>
            and <code>height</code>), so lets get the others.
            <div class='aside'>
              Remember, in SVG the top-left corner is (0, 0). x-coordinates
              increase to the right and y-coordinates increase down the page.
            </div>
            <code>x</code> is quite easy, actually. All bars should
            be aligned along the left axis, so they all have an <code>x</code>
            of 0. <code>y</code> takes a <em>bit</em> more thought, but not
            much (save those brain cells for something else). To place the bar
            for <code>0</code> at the top of the chart, and that for
            <code>10</code> at the bottom, the <code>i</code>-th even number
            should be offset by <code>i * barHeight</code>. Or, in a function:
            <code class='block js'>var barY = function(index) {
  return index * barHeight;
};</code>
            Now, we know from the <a href='lesson_1.html#s5'>last lesson</a>
            that <code>barY</code> is probably
            going to be provided as an argument to <code>attr</code>, and when
            a function is provided to <code>attr</code> it gets two arguments:
            first the <code>datum</code>, then the <code>index</code>.
            So we change the function to:
            <code class='block js'>var barY = function(datum, index) {
  return index * barHeight;
};</code>
            Putting all of this together, and choosing arbitrary colors, we get:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = 100;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('border', '1px solid black');

var evenNumbers = [0, 2, 4, 6, 8, 10];
var maxDataValue = d3.max(evenNumbers);
var barHeight = height / evenNumbers.length;
var barWidth = function(datum) {
  return datum * (width / maxDataValue);
};
var barX = 0;
var barY = function(datum, index) {
  return index * barHeight;
};
root.selectAll('rect.number')
    .data(evenNumbers).enter()
  .append('rect')
    .attr({
      'class': 'number',
      'x': barX,
      'y': barY,
      'width': barWidth,
      'height': barHeight,
      'fill': '#dff',
      'stroke': '#444',
    });</code>
              <code class='block result'></code>
            </div>
            <div class='aside'>
              New syntax! You might have noticed the <code>attr</code> function
              here was passed an <code>object</code> literal. Bet you haven't
              seen that before. Join the club. D3 is under
              <a href='https://github.com/mbostock/d3/wiki/Release-Notes'>constant development</a>
              and new features get added with some frequency.  Your author
              tries to keep up, but can't always be bothered.  Hopefully you
              pick better role models. Passing a map to the <code>attr</code>
              function (among others) is shorthand for calling
              <code>attr</code> for each (key, value) pair in the map.
             </div>
             <hr>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s2'>
            2.2 A bigger palette
          </div>
          <div class='section-content'>
            Contrary to the example we've set, SVG provides more primitives than
            the lowly <code>rect</code>. And you know what that means: more
            contrived examples. Let's consider a new graph - a <a href='http://xkcd.com/688/'>self-descriptive</a>
            one. A plot of circles, where the x-axis is
            the radius of the circle and the y-axis is the number of pixels
            in that circle (its area).
            <hr>
            The <code><a href='http://www.w3.org/TR/SVG/shapes.html#CircleElement'>circle</a></code>
            element is just what we need.  Like the <code>rect</code> before
            it, and all the future SVG elements we render, it supports a set of
            presentation attributes.
            <div class='aside'>
              Huh? What?  Afraid you fell asleep in class and missed the
              definition of the word? Nope, the teacher is just making you
              sweat. The <a href='http://www.w3.org/TR/SVG/styling.html#SVGStylingProperties'>presentation attributes</a>
              are the attributes which determine how a shape is rendered. We've
              already seen <code>fill</code> and <code>stroke</code>. There are
              more to come, but we won't be exhaustive. The SVG standard is,
              while not exactly readable, easy to browse and full of examples.
              Consider browsing it over coffee. Or not, actually. Don't do
              that.
            </div>
            While the presentation of a <code>circle</code> is the same as a
            <code>rect</code>, the positioning isn't. We need three attributes:
            The <code>circle</code> is centered at
            <span class='nobr'>(<code>cx</code>,</span>
            <code>cy</code>) and has a radius of <code>r</code>. So, building it
            much like the last one with a few changes:
            <code class='block js'>var circleX = function(radius) { return radius; };
var circleY = function(radius) { return Math.PI * radius * radius; };</code>
            Let's try radius values of <code>[1, 2, 3, 5]</code> as a starting
            point for the graph.
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = 100;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('background', 'white');

var circleRs = [1, 2, 3, 5];
var circleX = function(radius) { return radius; };
var circleY = function(radius) { return Math.PI * radius * radius; };
var circleR = function(radius) { return radius; };

root.selectAll('circle')
    .data(circleRs).enter()
  .append('circle')
    .attr({
        'cx': circleX,
        'cy': circleY,
        'r': circleR,
        'fill': '#ffcdcd',
        'stroke': '#666',
    });</code>
              <code class='block result'></code>
            </div>
            Hrm, not the best graph. We have a few obvious issues: first, 100
            pixels of height is not going to cut it at this scale if we want to
            have larger circles. Second, our elements are scrunched along the
            left. Thirdly, our y-axis is <em>reversed</em> from a normal graph.
            The third is easy to solve - instead of mapping the
            <code>radius</code> to <code>Math.PI * radius * radius</code>, we
            subtract that value from the height of the graph:
            <code>height - Math.PI * radius * radius</code>. Now top is bottom
            and bottom is top. The first two issues are both classes of the
            same problem - a scale where 1 unit along the axis is 1 pixel is
            tiny. Miniscule. Laughable. Infinitesimal. No, wait, that isn't
            right. We can definitely both see and measure the circles, so they
            must not be infinitesimal. Got carried away with my adjectives.
            <hr>
            When drawing a graph on paper, your scale is more likely to be
            closer to 10mm to 1 unit (we don't use imperial units here; we are
            snobby intellectuals). This is fixed by scaling our computed
            <code>cx</code> and <code>cy</code> values by an arbitrary number -
            <code>4</code> sounds good. Never done me wrong, trusty
            <code>4</code>.  We'll also need to change our bounds; if the
            largest circle is has a radius of <code>5</code>, we would like
            <code>height - 4 * Math.PI * 5 * 5</code> to not be negative; 350
            is big enough for that. Now, our new (and maybe improved) chart:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = <em>350</em>;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('background', 'white');

var circleRs = [1, 2, 3, 5];
var circleX = function(radius) { return <em>4 *</em> radius; };
var circleY = function(radius) { return <em>height - 4 *</em> Math.PI * radius * radius; };
var circleR = function(radius) { return radius; };

root.selectAll('circle')
    .data(circleRs).enter()
  .append('circle')
    .attr({
        'cx': circleX,
        'cy': circleY,
        'r': circleR,
        'fill': '#ffcdcd',
        'stroke': '#666',
    });</code>
              <code class='block result'></code>
            </div>
            In the tradition of all my favorite textbooks, I leave deciding if
            that is an improvement as an exercise for the reader.
            <span class='spoiler'>It really isn't much of an improvement. Not
            much could save the chart, really. Terribly dreadful, that.</span>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s3'>
            2.3 Tipping the scales
          </div>
          <div class='section-content'>
            While the previous example wasn't bad code, it isn't exactly
            idiomatic D3. It works, but D3 provides <a href='https://github.com/mbostock/d3/wiki/API-Reference'>helpers</a>
            to make our code easier to read and our intent clear. For
            example, <span class='nobr'><code><a href='https://github.com/mbostock/d3/wiki/Scales'>d3.scale</a></code>.</span>
            Note, in the last example, we inserted some magic
            values in our attribute functions (like <code>4</code> and
            <code>height</code>). But these were <em>separate</em> from the data
            we actually cared about - our <code>cx</code> is just the
            <code>radius</code> on some arbitrary scale, and the <code>cy</code>
            is likewise a <em>number</em> on some <em>scale</em>. In case the
            name, and this hammering of a point, did not clue you in,
            <code>d3.scale</code> and its many members are designed to assist
            us.
            <hr>
            Before we introduce our first scale, we'll define what a scale
            <em>is</em>. A scale is a function that maps input values to output
            values. Being mathematically-minded, the proper name for
            <em>input</em> is <em>domain</em>, and that of <em>output</em> is
            <em>range</em>.  Neither the domain nor range need be numbers, but
            starting there will be easiest. The simplest scale, then, is the
            identity function. We used that, implicitly, in the first circle
            example (the "bad" one). We mapped our data (radius) values to a
            value along some axis, then scaled that axis using the identity
            function.
            <hr>
            In the second, questionably improved, example, we scaled that axis
            by multiplying by 4. Our scale function was then <code>function(x) {
              return 4 * x; };</code>. This is an example of a
            <em>linear scale</em> (as, an astute reader will note, is the
            identity scale). D3 provides <code>d3.scale.linear</code> for just
            this purpose.
            <hr>
            The <a href='https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear'>
              documentation</a> for it is useful, but you can save the for
            later. The short of it is thus: <code>d3.scale.linear()</code>
            returns a new <code>object</code> that is <em>also</em> a
            <code>function</code>. The two methods of current interest on the
            object are <code>domain</code> and <code>range</code>. Both take an
            array of values that specify, respectively, the <em>domain</em> and
            <em>range</em> of the scale function. An example would prove
            instructive:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root');
var scale = d3.scale.linear()
    .domain([0, 10])
    .range([0, 100]);

root.selectAll('div')
    .data([0, 10, 5, -5, 100]).enter()
  .append('div')
    .text(function(d) {
      return 'The scaled value of ' + d + ' is ' + scale(d);
    });</code>
              <code class='block result'></code>
            </div>
            The first two lines are, hopefully, exactly as expected - an input
            of <code>0</code> (the first element of the domain) maps to an
            output of <code>0</code> (the first element of the range), just as
            <code>10</code> maps to <code>100</code>. The third value,
            <code>5</code> should also make sense - our scale is linear, so an
            input value halfway between the domain values of <code>0</code> and
            <code>10</code> maps to an output value halfway between the
            respective range values&mdash;<code>0</code> and <code>100</code>.
            <hr>
            The other two may be surprising, but follow from above. If an input
            value falls outside the domain, the scale pretends the domain and
            range are extended to include the value. If you don't like this
            behavior, you can call <code>.clamp(true)</code> on the scale to
            force all values to fall within the domain.
            <div class='aside'>
              Linear scales actually accept an array length <em>at least</em> 2
              for the domain and range. Specfying more than 2 values is a more
              advanced feature which may prove useful later, but now only
              serves to confuse. Read the <a href='https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_domain'>docs</a>
              or attempt to guess the semantics if you want, or just carry on
              with your life. All are valid paths.
            </div>
            We can use our scalar powers (sweet! only a Levenshtein distance of
            4 from super!) to improve the second circle example. Now, we have a
            lot of options available to us - <em>anything</em> that results in
            <code>1</code> mapping to <code>4</code> will work (as our scale just
            multiplied by 4). So what values to use for the domain and range?
            Why not the simplest - a domain of <code>[0, 1]</code> and a range
            of <code>[0, 4]</code>.
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 600;
var height = 350;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    })
    .style('background', 'white');

var circleRs = [1, 2, 3, 5];
<em>var xScale = d3.scale.linear()
    .domain([0, 1])
    .range([0, 4]);
var yScale = xScale;  // Our x and y use the same scale.
var circleX = function(radius) { return xScale(radius); };
var circleY = function(radius) { return height - yScale(Math.PI * radius * radius); };</em>
var circleR = function(radius) { return radius; };

root.selectAll('circle')
    .data(circleRs).enter()
  .append('circle')
    .attr({
        'cx': circleX,
        'cy': circleY,
        'r': circleR,
        'fill': '#ffcdcd',
        'stroke': '#666',
    });</code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s4'>
            2.4 Nope, sorry, that circles example is still rubbish
          </div>
          <div class='section-content'>
            And I'm not going to let it rest until that code is <em>good</em>
            (even if the source of the chart is contrived). The <code>yScale</code>
            used in the example is, frankly, an embarrassment. Look at our
            <code>circleY</code> function again:
            <code class='block js'>var circleY = function(radius) { return height - yScale(Math.PI * radius * radius); };</code>
            We still have parts of our conversion from axis to pixels (our
            original motivation for scales) <em>outside</em> of the scale
            definition. I'm speaking, of course, of that pesky <code>height
              -</code> that begins our function. So, to fix it, we need to put
            on our thinking caps.
            <hr>
            We need two input values and two output values for a scale. We have
            a trivially easy one - the input value of <code>0</code> maps to the
            output value of <code>height</code>. That was fun! Plug and play
            sure is easier than Windows 95 led me to believe... and we can just
            put in another input value to get another output value.
            <hr>
            But <em>what</em> input value? We can choose one arbitrarily and it
            will just work. Why not <code>1</code>, which maps to <code>height -
              yScale(Math.PI * 1 * 1)</code> or simply
            <code>337.4336blahblahblah</code>. Or actually simpler in the form
            of <code>height - 4 * Math.PI</code>. Just put that in our code,
            right? Problem solved?
            <code class='block js'>var scaleY = d3.scale.linear()
    .domain([0, 1])
    .range([height, height - 4 * Math.PI]);</code>
            Not so fast. The only thing we've accomplished is moving a magic
            number from one place to another.  The <code>4</code> introduced
            into this function comes from our <code>xScale</code>, and the
            <code>Math.PI</code> comes from our mapping of <code>data</code>
            values to <code>y</code> values. We have conflated two things: the
            mapping from data to y, and the mapping from y to pixels. We can
            make this more clear by introducing functions:
            <code class='js block'>var dataToY = function(d) {
  return Math.PI * d * d;
};

var yScale = d3.scale.linear()
    .domain([0, 1])
    .range([height - 4 * dataToY(0), height - 4 * dataToY(1)]);

var circleY = function(d) {
  return yScale(dataToY(d));
};</code>
            Now our path from the <code>data</code> bound to each
            <code>circle</code> to the final resting <code>y</code> is clear.
            <div class='aside'>
              Another option would have been a different set of
              <code>data</code> values.  Instead of an array of
              <code>radius</code> numbers, it could have been an array of
              objects, each with a <code>radius</code> and <code>area</code>
              property. This would have removed the need for the <code>dataToY</code>
              function at the cost of more verbose data. There are reasons for
              keeping the bound data simple and reasons for binding very complex
              objects, and no easy rule to follow.
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s5'>
            2.5 Once more unto the... graph
          </div>
          <div class='section-content'>
            Before moving on to more advanced data bindings, we'll feature
            one last example that introduces some additional elements of SVG
            used in most visualizations. We'll start with a description of the
            problem, the complete solution, and follow it with a explanation
            of some of the new bits. So, let's graph!
            <hr>
            But what? Histograms. Simple, and easy. And practical, too. Pretend
            (or not, as necessary) that you play a <a href='http://en.wikipedia.org/wiki/Tabletop_role-playing_game'>tabletop roleplaying game</a>
            as some character that hits things with other things. You just got
            a sweet new things to hit other things with - an <em>eldritchian
              quadruple axe</em> (it's pretty cool, trust me). When you hit
            things with this thing, you roll <a href='http://en.wikipedia.org/wiki/Dice_notation'>2d4 + 2d6</a>
            for damage, assuming the enemy fails their sanity check, and half
            rounding down otherwise. Now, you received <em>DJs boombox of "Call
              Me Maybe"</em> in your last quest (for those not familiar with the
            game, that is a cursed amulet that makes everyone within 50m fail
            their sanity checks) so the math here is going to be easy. Which is
            good, because some members of your party just stare at you blindly
            when you say <em>probability mass function</em> and you just want
            to demonstrate how awesome this new axe is. You need a pretty
            picture to illustrate.
            <hr>
            A picture of a histogram, of course.
            <hr>
            We'll simulate 500 attacks with your axes and graph the
            resulting histogram. And we'll pick, arbitrarily, 640x480 pixels
            as the size. With a title and nicely-labeled axes for our axes.
            <div class='sample'>
              <code class='block html'>&lt;style type='text/css'&gt;
  svg {
    border: 1px solid black;
    background: white;
  }

  .axis .domain, .axis .tick {
    stroke: #000;
    fill: none;
  }

  .title {
    fill: #666;
    font-family: Helvetica, sans-serif;  /* Helvetica is cool, right? */
    text-anchor: middle;
    font-size: 24px;
  }

  .bar {
    fill: #fcc;
    stroke: #444;
  }
&lt;/style&gt;
&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 640;
var height = 480;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    });

// Render the title.
var titleHeight = 50;
root.append('text')
    .attr({
      'class': 'title',
      'x': width / 2,
      'y': titleHeight / 2,
    })
    .text('Skull-splitting power!');

// Simulate 500 rolls of the axe.
var rollDie = function(numSides) {
  return 1 + Math.floor(Math.random() * numSides);
};

var MAX_ROLL = 4 + 4 + 6 + 6;
var rollHisto = d3.range(MAX_ROLL + 1).map(function() { return 0; });
for (var i = 0; i &lt; 500; i++) {
  var rolled = rollDie(4) + rollDie(4) + rollDie(6) + rollDie(6);
  rollHisto[rolled]++;
}

// Render our axis.
var yAxisWidth = 50;
var xAxisHeight = 50;

var xScale = d3.scale.linear()
    .domain([0, rollHisto.length])
    .range([yAxisWidth, width]);
var yScale = d3.scale.linear()
    .domain([0, d3.max(rollHisto) * 1.2])
    .range([height - xAxisHeight, titleHeight]);

var xAxis = d3.svg.axis().scale(xScale);
root.append('g')
    .attr({
      'class': 'x axis',
      'transform': 'translate(0,' + (height - xAxisHeight) + ')',
    })
    .call(xAxis);

var yAxis = d3.svg.axis().scale(yScale).orient('left');
root.append('g')
    .attr({
      'class': 'y axis',
      'transform': 'translate(' + yAxisWidth + ',0)',
    })
    .call(yAxis);

// Render the dice bars.
root.selectAll('rect.bar')
    .data(rollHisto).enter()
  .append('rect')
    .attr({
      'class': 'bar',
      'x': function(d, i) { return xScale(i - 0.5); },
      'width': xScale(1) - xScale(0),
      'y': yScale,
      'height': function(d) { return yScale(0) - yScale(d); },
    });</code>
              <code class='block result'></code>
            </div>
            <em>Phew!</em> That was quite a bit of code, and much of it new.
            First order of business: this example used CSS. Yes, CSS. You see,
            I know I mentioned this in the last lesson as an advanced topic.
            Congratulations, your SVG is now advanced! Gold star! Styling your
            charts the same way you would style your documents is done for the
            same reason - keeping presentation separate from content is good.
            It is a little more complicated with CSS as some things you think
            of as presentation in CSS are, conceptually, part of the content in
            SVG. Namely, the position and dimension of an element.
            <hr>
            Some readers may have spotted another difference: some of those CSS
            properties aren't valid. True, <code>text-anchor</code> isn't a
            style property for HTML elements, but it works just fine for SVG.
            The complete list of all valid properties to put in CSS is available
            <a href='http://www.w3.org/TR/SVG/styling.html'>in the spec</a>.
            <div class='aside'>
              In addition to <code>text-anchor</code>, there is another
              commonly used attribute: <span class='nobr'><code>dy</code>.</span>
              The <code>dy</code> of a <code>text</code> element is the amount,
              in any units, the text should be offset from its defined <code>y</code>
              position. How is this useful? Vertically aligning text. There are
              some "magic" values one can use with <code>dy</code> to get a variety
              of effects. A <code>dy</code> of <code>0.3em</code> vertically
              centers the text along the defined <code>y</code> position. A
              <code>dy</code> of <code>0.7em</code> aligns the top of the text
              at the defined <code>y</code> position. And, obviously, a
              <code>dy</code> of <code>1em</code> moves the text down a
              line from the defined <code>y</code> attribute. These numbers
              aren't actually magic, but follow from the <a href='http://en.wikipedia.org/wiki/Em_(typography)'>definition of the em unit</a>.
            </div>
            The next new bit is the <code><a href='http://www.w3.org/TR/SVG/text.html'>text</a></code>
            element used for the title. Just to confuse you, <code>text</code>
            in SVG behaves nothing like in HTML, nor like <code>rect</code>s
            in SVG. Ignoring any centering or offsets, the <code>x</code> and
            <code>y</code> attributes determine the left and <em>baseline</em>,
            not top or mid, positions of the initial character. So far, so good.
            The big annoyance: it <em>does not wrap</em>.
            It will overflow as necessary and you can't <em>easily</em> prevent
            this. It sucks. For serious text layout in SVG, I suggest two good
            options. If you know your data, lay your text out by hand, assuming
            everything will fit (which it will, because you can modify as
            needed). If you don't know your data, I suggest using HTML - either
            with <code>absolute</code> positioned nodes or with a <a href='http://www.w3.org/TR/SVG/extend.html#ForeignObjectElement'>foreignObject</a>
            (to embed HTML within SVG). Neither of the HTML options are great,
            mind you, but they do work.
            <div class='aside'>
              Another option for laying out unknown text is to render, offscreen,
              the text you wish to layout and use some of the <a href='http://www.w3.org/TR/SVG/text.html#DOMInterfaces'>DOM interface methods</a>
              to query the size of the text, such as <code>getComputedTextLength</code>.
              Alternatively, you can use the <code>getBBox</code> method (on the
              <code><a href='http://www.w3.org/TR/SVG/types.html#InterfaceSVGLocatable'>SVGLocatable</a></code>
              DOM interface) to get the height as well.
            </div>
            Lets talk about the presentation a bit: we have a title that takes
            up the top of the chart, and x-axis that takes up the bottom, and a
            y-axis on the left. Each bar is <em>centered</em> on the dice roll
            it represents, and our data on how many times the dice summed to
            <code>n</code> is in <span class='nobr'><code>rollHisto[n]</code>.</span>
            The area for drawing bars in then spans from the end of the y-axis
            to the edge of the chart.
            <hr>
            You may have noticed a few variables scattered about the code - in
            addition to the <code>width</code> and <code>height</code> of
            previous examples, we additionally have
            <span class='nobr'><code>xAxisHeight</code>,</span>
            <span class='nobr'><code>yAxisWidth</code>,</span> and
            <span class='nobr'><code>titleHeight</code>.</span> Knowing this,
            our x scale should be obvious; the value <code>0</code> maps to
            the edge of the y-axis, and the value <code>rollHisto.length - 1</code>
            (the highest data value to graph) should be close to, but not at,
            the edge of the chart. Hence:
            <code class='block js'>var xScale = d3.scale.linear()
    .domain([0, rollHisto.length])
    .range([yAxisWidth, width]);</code>
            Which, I might add, is a lot more obvious than the constant-less
            version with a <code>range</code> of
            <span class='nobr'><code>[480, 50]</code>.</span>
            The y scale is similar, with the added complexity of it being
            inverted; a value of <code>0</code> maps to the highest y-value,
            namely <code>height - xAxisHeight</code>.
            <div class='aside'>
              Going back to our <a href='#s4'>"not-so-rubbish" circle example</a>,
              we could improve it yet again. Instead of defining the <code>xScale</code>
              and <code>yScale</code> as having domains of <code>[0, 1]</code>,
              we can define them as having a more <em>natural</em> domain.
              Like <code>[0, d3.max(circleRs)]</code> for the <code>xScale</code>
              and <code>[0, dataToY(d3.max(circleRs))]</code> for the
              <span class='nobr'><code>yScale</code>.</span> The ranges,
              then, would be <code>[0, width]</code> and
              <span class='nobr'><code>[0, height]</code>.</span> Our scale
              is no longer <em>perfect</em>, but we could change the definition
              of <code>width</code> and <code>height</code> to get the original
              definition. This isn't as simple as I've led on, hence ignoring
              it. But, generally, domains and ranges should be natural
              from the domain of data you wish to render to the range of pixels
              you have to render in.
            </div>
            The scales we have also let us do some nice tricks. The center
            of each bar is at <code>xScale(i)</code>, as our scale is defined.
            This means the left edge should be halfway between <code>i - 1</code>
            and <code>i</code> - which we can put directly into the definition as
            <span class='nobr'><code>xScale(i - 0.5)</code>.</span> The
            <code>width</code> of each bar, then, should be the distance between
            <code>i - 0.5</code> and <span class='nobr'><code>i + 0.5</code>.</span>
            As our scale is linear, each bar has the same width and we simplify
            this to <code>xScale(1) - xScale(0)</code>. As before, so again, the
            y-scale is defined in a similar fashion, using the <code>yScale</code>
            to determine the <code>y</code> and <span class='nobr'><code>height</code>.</span>
            <hr>
            The next wrinkle is our axes - the most confusing, and new, piece
            of code. The easiest part to explain is the wonderful
            <code><a href='http://www.w3.org/TR/SVG/struct.html#Groups'>g</a></code>
            element. We use this element mostly for two purposes: it can have
            children elements, and it allows one to apply a <code><a href='http://www.w3.org/TR/SVG/coords.html#TransformAttribute'>transform</a></code>
            to those children. This element forms the bread-and-butter of
            many interesting graphs, paralleling the uses of a <code>div</code>
            element in HTML. It allows elements to be grouped together, both
            in the structure of the document and in the presentation.
            <hr>
            We commonly use the <code><a href='http://www.w3.org/TR/SVG/coords.html#TransformAttribute'>transform</a></code>
            attribute just mentioned for its <code>translate</code> form - to
            offset a set of elements from their normal position by a set amount
            in the <code>x</code> and <code>y</code> directions. The other forms,
            which allow a full range of affine transformations, won't be covered
            here.
            <hr>
            So how does that help us? Well, the <code>d3.svg.axis</code> helper
            isn't the smartest, or most configurable, kid in the shed. This is
            by design (I think). <code>d3.svg.axis</code> is a function that
            takes a <code>selection</code> and appends elements to it that
            resemble a labeled axis. By default,
            drawing a line from the start to the end of some scale along the x-axis,
            positioned with a <code>y</code> of <code>0</code>, with ticks and labels
            below. The simplistic interface doesn't allow us to specify where
            this is positioned. If you browse the <a href='https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-axis'>documentation</a>
            you won't find any such method. So, <code>g</code> to the rescue!
            Translating all the elements rendered for the axis down by <code>height - xAxisHeight</code>
            gets the desired position.
            <hr>
            You'll also notice the docs don't mention anything about the
            presentation of the axis elements, so I'll clue you in. There is
            a <code>path</code> element that runs parallel to the axis with
            a class of <code>domain</code> and many <code>line</code> elements
            forming the perpendicular tick marks with, conveniently, a class
            of <span class='nobr'><code>tick</code>.</span> The <code>text</code>
            labels have no class. Given all of this information, we can easily
            use CSS to change the display, even hiding bits if we don't like them
            with a <code>stroke</code> and <code>fill</code> of none.
            <hr>
            To determine which way the axis runs, and which side the labels
            get placed on, you use the <code><a href='https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-orient'>orient</a></code>
            method. And, to define the scale used, the <code><a href='https://github.com/mbostock/d3/wiki/SVG-Axes#wiki-scale'>scale</a></code>
            method is used.
            <div class='aside'>
              The rendered axis goes from the start of the scale to the end, so
              if you had used a not-so-obvious scale definition, it would not
              work out so nicely. Like in our previous example of a y-scale
              with a domain of <code>[0, 1]</code>.
            </div>
            And that is about it. Except that pesky <code>call</code> method
            we called with the <code>d3.svg.axis</code> object. This is a
            helper method; <code>selection.call(fn)</code> is equivalent to
            <code>fn(selection); return selection;</code> - enabling method
            chaining.
        </div>
      </div>
        <div class='section'>
          <div class='section-header' id='s6'>
            2.6 An optional, and not necessary, detour into style
          </div>
          <div class='section-content'>
            This is a short section that, at one point in writing, was a note
            in the above example. But, it was much too long as a note and so
            it rests, here, mostly unloved and entirely alone. Wait, not so
            unloved - you! You, reader, are reading me! Oh, most frabjous day!
            <hr>
            So, style. After reading about the <code>g</code> element and
            <code>transform</code> attribute, a smart question could have been
            posited: why not render the bars from the histogram into their
            own little <span class='nobr'><code>g</code>,</span> offset from
            the cruel identity transform and in their own little world? Why
            not have the <code>xScale</code> keep its domain, but have a range
            of <span class='nobr'><code>[0, width - yAxisWidth]</code>?</span>
            And, of course, the same for the <span class='nobr'><code>yScale</code>?</span>
            Other than requiring we place all the <code>rect</code> elements
            inside a <code>g</code> with <code>translate</code> of
            <span class='nobr'><code>'transform(' + yAxisWidth + ', ' + titleHeight + ')'</code>,</span>
            it seems more clear.
            <div class='aside'>
              Nothing will excuse the ugliness of that string concatenation,
              though. But a clever coder might realize the stringification of
              an array is the same as <code>array.join(', ')</code> and write
              ever-so-short, ever-so-clever code. And receive a gold star from
              me. Then, maybe, a slap.
            </div>
            However, a nice scale for our graph creates a less-nice situation
            for our <code>d3.svg.axis</code> calls. Unless...
            <hr>
            Of course! Unless one were to <em>also</em> put the <code>g</code>
            elements inside the bar's <code>g</code> element. Which of these is
            better? For a toy example such as this one, it really doesn't
            matter. As graphs get more complex, you will learn to trust the
            <code>g</code> element more than its humble name suggest. You may,
            in fact, start calling it your <span class='nobr'><code>G</code>.</span>
            For reference, here is the fully-updated example:
            <div class='sample'>
              <code class='block html'>&lt;style type='text/css'&gt;
  svg {
    border: 1px solid black;
    background: white;
  }

  .axis .domain, .axis .tick {
    stroke: #000;
    fill: none;
  }

  .title {
    fill: #666;
    font-family: Helvetica, sans-serif;  /* Helvetica is cool, right? */
    text-anchor: middle;
    font-size: 24px;
  }

  .bar {
    fill: #fcc;
    stroke: #444;
  }
&lt;/style&gt;
&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var width = 640;
var height = 480;
var root = d3.select('#chart').append('svg')
    .attr({
      'width': width,
      'height': height,
    });

// Render the title.
var titleHeight = 50;
root.append('text')
    .attr({
      'class': 'title',
      'x': width / 2,
      'y': titleHeight / 2,
    })
    .text('Skull-splitting power!');

// Simulate 500 rolls of the axe.
var rollDie = function(numSides) {
  return 1 + Math.floor(Math.random() * numSides);
};

var MAX_ROLL = 4 + 4 + 6 + 6;
var rollHisto = d3.range(MAX_ROLL + 1).map(function() { return 0; });
for (var i = 0; i &lt; 500; i++) {
  var rolled = rollDie(4) + rollDie(4) + rollDie(6) + rollDie(6);
  rollHisto[rolled]++;
}

var yAxisWidth = 50;
var xAxisHeight = 50;

<em>// Define the root g element.
var histoWidth = width - yAxisWidth;
var histoHeight = height - xAxisHeight - titleHeight;
var histoG = root.append('g')
    .attr({
      'class': 'histo',
      'transform': 'translate(' + yAxisWidth + ', ' + titleHeight + ')',
    });
</em>

// Render our axis.
var xScale = d3.scale.linear()
    .domain([0, rollHisto.length])
<em>    .range([0, histoWidth]);</em>
var yScale = d3.scale.linear()
    .domain([0, d3.max(rollHisto) * 1.2])
<em>    .range([histoHeight, 0]);</em>

var xAxis = d3.svg.axis().scale(xScale);
histoG.append('g')
    .attr({
      'class': 'x axis',
<em>      'transform': 'translate(0, ' + histoHeight + ')',</em>
    })
    .call(xAxis);

var yAxis = d3.svg.axis().scale(yScale).orient('left');
histoG.append('g')
    .attr('class', 'y axis')
    .call(yAxis);

// Render the dice bars.
histoG.selectAll('rect.bar')
    .data(rollHisto).enter()
  .append('rect')
    .attr({
      'class': 'bar',
      'x': function(d, i) { return xScale(i - 0.5); },
      'width': xScale(1) - xScale(0),
      'y': yScale,
      'height': function(d) { return yScale(0) - yScale(d); },
    });</code>
              <code class='block result'></code>
            </div>
        </div>
        A bit cleaner, if not shorter. In the next lesson, we'll dive back into
        data bindings. As you may have learned to expect, I've hidden a bit of
        complexity in previous descriptions. But, trust me, it was for the
        best. So, next time, "you got data in my data!" and other adventures
        in binding land.
      </div>
    </div>
    <div class='footer'>
      <div class='content'>
        Copyright 2012 <a href='http://hazzens.com'>Mikey Levine</a>
        &mdash; <a href='atom.xml'>New Lesson Feed</a>
        <div class='float-right'>
          Built using <a href='http://d3js.org'>D3</a> and
          <a href='https://github.com/einars/js-beautify'>js-beautify</a>
        </div>
      </div>
    </div>
  </body>
  <script type="text/javascript">
    tut.init();
  </script>
</html>
