<html>
  <head>
    <meta charset="utf-8">
    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="Lessons ATOM Feed">
    <link href="reset.css" rel="stylesheet" type="text/css">
    <link href="base.css" rel="stylesheet" type="text/css">
    <title>
      D3, Conceptually - Lesson 4: Changing Data
    </title>
    <script type="text/javascript" src="d3.v2.min.js"></script>
    <script type="text/javascript" src="base.js"></script>
    <script type="text/javascript" src="lesson_3.js"></script>
    <script type="text/javascript" src="beautify-html.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24357809-1']);
      _gaq.push(['_setDomainName', 'hazzens.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class='header'>
      <div class='left-bar'>
      </div>
      <div class='content'>
        <h1 id='masthead'>
          D3, Conceptually
        </h1>
        <h2 class='lesson'>
          Lesson 4: Changing Data
        </h2>
      </div>
    </div>
    <div class='main'>
      <div class='left-bar'>
        <h2 class='border-bottom'>index</h2>
        <ul class='pad-top selector'>
          <li><a href='lesson_0.html'>0. Preface</a></li>
          <li><a href='lesson_1.html'>1. Introductory elements</a></li>
          <li><a href='lesson_2.html'>2. Charts</a></li>
          <li><a href='lesson_3.html'>3. (Moderately) Advanced Data</a></li>
          <li class='selected'><a href='lesson_4.html'>4. Changing Data</a></li>
        </ul>
      </div>
      <div class='content'>
        <div class='prev-link'>
          <a href='lesson_3.html'>&laquo; previously: (moderately) advanced data</a>
        </div>
        <div class='next-link'>
        </div>
        <div class='clearfix pad-top'></div>
        <div class='section'>
          <div class='section-header' id='s1'>
            4.1 Two nodes leave, no nodes enter
          </div>
          <div class='section-content'>
            In all previous lessons, we've only added data or modified data.
            Never have we <em>removed</em> data from a loving home.
            Our <a href='lesson_1.html#s6'>introduction of the <code>enter</code> selection</a>
            left a question unspoken - what if one had less data? Would there
            be a corresponding <code>exit</code> selection to match?
            <div class='sample'>
              <code class='block html'>&lt;div class='captain'&gt;Kirk&lt;/div&gt;
&lt;div class='captain'&gt;Picard&lt;/div&gt;
&lt;div class='captain'&gt;Sisko&lt;/div&gt;
&lt;div class='captain'&gt;Janeway&lt;/div&gt;
&lt;div class='captain'&gt;Archer&lt;/div&gt;</code>
              <code class='block js'>var captainNames = [
  'Kirk',
  'Picard',
  'Sisko',
  'Janeway',
  // I never liked Enterprise.
  // 'Archer',
];
var captains = d3.selectAll('.captain').data(captainNames);
<em>captains.exit()
    .remove();</em>
captains
    .text(String);</code>
              <code class='block result'></code>
            </div>
            The <code>remove</code> function, rather obviously, removes the
            selection from the DOM. Its use isn't limited to <code>exit</code>
            selections, but it is most commonly used there. You also need not
            remove the <code>exit</code>ing nodes - there is nothing inherently
            special about the selection and it functions identically to the
            <code>update</code> selection. Except, of course, it has no data:
            <div class='sample'>
              <code class='block html'>&lt;div class='captain'&gt;Kirk&lt;/div&gt;
&lt;div class='captain'&gt;Picard&lt;/div&gt;
&lt;div class='captain'&gt;Sisko&lt;/div&gt;
&lt;div class='captain'&gt;Janeway&lt;/div&gt;
&lt;div class='captain'&gt;Archer&lt;/div&gt;</code>
              <code class='block js'>var captainNames = [
  'Kirk',
  'Picard',
  'Sisko',
  'Janeway',
  // I never liked Enterprise.
  // 'Archer',
];
var captains = d3.selectAll('.captain').data(captainNames);
captains.exit()
    .style('color', 'grey')
    .text(function(d, i) { return 'data: [' + d + '], index: [' + i + ']'; });
captains
    .text(String);</code>
              <code class='block result'></code>
            </div>
            But how, exactly, does d3 decide which nodes are in the exit
            selection? If the data started as <span class='nobr'><code>[0, 2, 4]</code></span>
            and was <code>update</code>-d to <span class='nobr'><code>[2, 4, 6]</code>,</span>
            would any nodes <code>exit</code>? With the tools presented so
            far, <em>no</em>. Just as <code>enter</code> is defined as all the
            new indices with data, <code>exit</code> is all the indices that no
            longer have data. Consequently, we can't have an <code>enter</code>
            and an <code>exit</code> from the same <code>data</code> binding. At
            least, not yet. Consider the following example:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var chart = d3.select('#chart');
chart.selectAll('div')
    .data([0, 2, 4]).enter()
  .append('div')
    .text(String);

var divs = chart.selectAll('div')
    .data([2, 4]);

divs.exit()
    .style('color', 'grey')
    .text('Poor, unloved datum');
divs
    .text(function(d) { return d + ' - still kicking'; });</code>
              <code class='block result'></code>
            </div>
            As expected, the <em>last</em> node is the <code>exit</code>-ing node.
            The mapping from pre-<code>update</code> node to post-<code>update</code>
            node is by index. The node formerly known as <code>0</code> is now
            known as <code>2</code> after the <code>update</code>.
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s2'>
            4.2 A new dawn for data - the key
          </div>
          <div class='section-content'>
            One last bit before animations - key functions. Many of the functions
            we've seen in D3 have additional, optional params. <code>data</code>
            is no exception. In addition to the first argument (to specify the data),
            it accepts a <em>key function</em> as a second argument. What's a key
            for, huh? To unlock doors, of course. Doors to data-binding fun!
            <hr>
            Or, you know, something else. The key function allows one to specify
            a data mapping from pre-<code>update</code> to post-<code>update</code>
            instead of the default by-index behavior. In other words, it defines
            if a datum is exiting, entering, or updating. Consider our previous
            example, but with a key function that defines an identity mapping:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var chart = d3.select('#chart');
<em>var keyFn = function(d) { return d; };</em>
chart.selectAll('div')
    .data([0, 2, 4], <em>keyFn</em>).enter()
  .append('div')
    .text(String);

var divs = chart.selectAll('div')
    .data([2, 4], <em>keyFn</em>);

divs.exit()
    .style('color', 'grey')
    .text('Poor, unloved datum');
divs
    .text(function(d) { return d + ' - still kicking'; });</code>
              <code class='block result'></code>
            </div>
            The function, like most D3 functions, is passed two params:
            <code>data</code> and <code>index</code> along with the <code>this</code>
            bound to the appropriate <code>Element</code>. To pair nodes up with
            data, D3 calls the <code>key</code> function on each selected node
            and on the fresh data. The <code>exit</code> selection is all nodes
            selected with a key not present in the fresh data (in set terms,
            <code>{key(node): node &isin; selected} - {key(datum): datum &isin; data}</code>.
            Likewise, <code>enter</code> is all nodes with keys in fresh data, but not in
            selected and the basic selection is all selected nodes with a matching
            key in data (
            <code>{key(node): node &isin; selected} &cap; {key(datum): datum &isin; data}</code>).
            <hr>
            What does this mean for us? Well, the first node in the tree is now
            grey, not the last. That is about it. We'll find this useful in the
            next section. One last thing to note: the returned key is
            <code>string</code>-ified, so using an <code>Array</code> or <code>
            Object</code> will lead to all data having the same key - not a good
            thing.
            <div class='aside'>
              If you are the kind that likes to cause trouble, find flaws in
              things, or worry about corner cases - have you checked for
              backdoors in your compiler yet? Also, let me head off two
              possible questions. First, the <code>key</code> function only
              matters at the time of calling <code>data</code>, and only for
              that single call. Previous and future calls could use a different
              function. Second, if your key function does not provide a unique
              mapping you are in for a world of hurt - the <code>enter</code> and
              <code>exit</code> sets will be mystifying.
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s3'>
            4.3 Enter-Update-Exit
          </div>
          <div class='section-content'>
            Example code, up until this point, as been a single-run affair - we
            select some nodes, we update attributes on them, and we go on our
            way. What if we wish for our method to be more than a fling? What if
            we want our callers to call us (maybe)?
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum')
      .text(d3.format('.2f'));
};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            What happened? Why doesn't the text update? Shouldn't we get a fresh
            set of five numbers each time <code>renderData</code> is called? No,
            not with this code. Now that our function is called multiple times,
            we must consider when attributes can change and when they can't.
            Shoulde the <code>class</code> of a <code>div</code> in this example
            ever change? Should the <code>text</code> of a <code>div</code>
            change? To answer these questions, consider how the attribute is
            set. If your attribute depends on <code>data</code>, then it can
            change. And attributes that can change should be set on the
            <em>entire</em> selection:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
<em>  // The number changes each time; ensure the text does as well.
  numbers
      .text(d3.format('.2f'));</em>
};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Far out! Now, I've written this code in a very specific order - the
            order from the section title. <code>enter</code> before
            <code>update</code> (our fancy name for operating on the original
            selection). What if we write it in the reverse order?
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'><div class='hide'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
</div>  numbers
      .text(d3.format('.2f'));
  numbers.enter().append('div')
      .attr('class', 'datum');
<div class='hide'>};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</div></code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s4'>
            4.4 Animate
          </div>
          <div class='section-content'>
            Drumroll - animation time! Animations in D3 are very simple to
            initiate. And, as is wont for easy tasks, easy to mess up. A
            <code><a href='https://github.com/mbostock/d3/wiki/Selections#wiki-transition'>
            transition</a></code> is just another function called on a selection.
            It takes no arguments and returns a <code><a href='https://github.com/mbostock/d3/wiki/Transitions'>d3.transition</a></code>
            object. You could read all about them by clicking on the link, or
            you could keep reading my tutorial. Maybe both? Wouldn't want to hurt
            mine nor mbostock's feelings, now would you?
            <hr>
            A <code>d3.transition</code> acts just like a
            <code>selection</code> with a few extra methods tacked on, and a
            few other methods removed. The three most important methods are
            retained - <code>attr</code>, <code>style</code>, and <code>text</code>.
            These three will continue as your bread-and-butter of D3. As you may
            have guessed from the identical names, <code>attr</code>, <code>style</code>,
            and <code>text</code> accomplish the same ends, with the same arguments,
            as the <code>d3.selection</code> methods.
            <hr>
            With one difference, of course. The three setters will not immediately
            set the <code>attr</code>/<code>style</code>/<code>text</code> of
            nodes in the selection, but instead gradually change them from the
            current value to the one specified. Gradual change is best, oddly,
            visualized:
            <div class='sample'>
              <code class='block html'>&lt;style type='text/css'&gt;
  div.bar {
    background: #ccf;
    border: 1px solid black;
    margin: 5px 0;
  }
&lt;/style&gt;
&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root');
var renderBars = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var widthScale = d3.scale.linear()
      .range([0, 300]);
  var bars = root.selectAll('div.bar').data(data);
  bars.enter().append('div')
      .attr('class', 'bar');
  bars.transition()
      .text(d3.format('.2f'))
      .style('width', widthScale);
  bars.exit()
      .remove();
};

root.append('button')
    .text('run renderBars')
    .on('click', renderBars);</code>
              <code class='block result'></code>
            </div>
            While the code is short, concise, and similar to many of our past
            examples, a few differences should be noted. Firstly, it animates.
            Cool beans! Now you can go impress all the potential romantic
            partners with your ability to make bars dance without Flash. Also,
            the code is broken into three distinct parts. We will call those
            <code>enter</code>, <code>update</code>, and <code>exit</code>
            (coinciding nicely with the method names in two fo the three cases).
            Thirdly, and as a result of the previous bullet, the code is
            repeatable. It can be called as many times as desired, and will
            always render the latest data, replacing the previous.
            <hr>
            Though, you'll note, I've written this example in a way that only
            the <code>update</code> portion runs on a button click - no nodes
            ever <code>exit</code> as the data size is fixed at five elements
            and, likewise, none ever <code>enter</code> because the initial
            render call is run on page-load. An example that uses all three may
            be instructive:
            <hr>
            <em>TODO: this should be delayed, talk about above example
              first</em>
            <hr>
            <div class='sample'>
              <code class='block html'>&lt;style type='text/css'&gt;
  rect.bar {
    fill: #ccf;
    stroke: #000;
  }
&lt;/style&gt;
&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root');
var w = 300;
var h = 100;
var svg = root.append('svg')
    .attr('width', w)
    .attr('height', h);

var xScale = d3.scale.linear()
    .range([0, w]);
var yScale = d3.scale.linear()
    .domain([0, 5])  // We will have 3-5 datums.
    .range([0, h]);

var renderBars = function() {
  var numData = 3 + Math.floor(Math.random() * 3);  // 3-5 numbers
  var data = d3.range(numData).map(Math.random);    // between [0, 1)

  var bars = svg.selectAll('rect.bar').data(data);
  var newBars = bars.enter().append('rect')
      .attr('class', 'bar')
      .attr('opacity', 0)
      .attr('x', xScale(0))
      .attr('y', function(d, i) { return yScale(i + 0.1); })
      .attr('height', function(d, i) { return yScale(i + 0.9) - yScale(i + 0.1);});
  bars.transition()
      .attr('width', xScale)
      .attr('opacity', 1);
  bars.exit().transition()
      .attr('opacity', 0)
      .attr('width', 0)
      .remove();
};

root.append('br');

root.append('button')
    .text('run renderBars')
    .on('click', renderBars);</code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class='footer'>
      <div class='content'>
        <div class='prev-link'>
          <a href='lesson_3.html'>&laquo; previously: (moderately) advanced data</a>
        </div>
        <div class='next-link'>
        </div>
        <div class='clearfix pad-top'></div>
        Copyright 2012 <a href='http://hazzens.com'>Mikey Levine</a>
        &mdash; <a href='atom.xml'>New Lesson Feed</a>
        <div class='float-right'>
          Built using <a href='http://d3js.org'>D3</a> and
          <a href='https://github.com/einars/js-beautify'>js-beautify</a>
        </div>
      </div>
    </div>
  </body>
  <script type="text/javascript">
    tut.init();
    tut3.init();
  </script>
</html>
