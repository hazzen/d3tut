<html>
  <head>
    <meta charset="utf-8">
    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="Lessons ATOM Feed">
    <link href="reset.css" rel="stylesheet" type="text/css">
    <link href="base.css" rel="stylesheet" type="text/css">
    <title>
      D3, Conceptually - Lesson 4: Changing Data
    </title>
    <script type="text/javascript" src="d3.v2.min.js"></script>
    <script type="text/javascript" src="base.js"></script>
    <script type="text/javascript" src="lesson_3.js"></script>
    <script type="text/javascript" src="beautify-html.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24357809-1']);
      _gaq.push(['_setDomainName', 'hazzens.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class='header'>
      <div class='left-bar'>
      </div>
      <div class='content'>
        <h1 id='masthead'>
          D3, Conceptually
        </h1>
        <h2 class='lesson'>
          Lesson 4: Changing Data
        </h2>
      </div>
    </div>
    <div class='main'>
      <div class='left-bar'>
        <h2 class='border-bottom'>index</h2>
        <ul class='pad-top selector'>
          <li><a href='lesson_0.html'>0. Preface</a></li>
          <li><a href='lesson_1.html'>1. Introductory elements</a></li>
          <li><a href='lesson_2.html'>2. Charts</a></li>
          <li><a href='lesson_3.html'>3. (Moderately) Advanced Data</a></li>
          <li class='selected'><a href='lesson_4.html'>4. Changing Data</a></li>
        </ul>
      </div>
      <div class='content'>
        <div class='prev-link'>
          <a href='lesson_3.html'>&laquo; previously: (moderately) advanced data</a>
        </div>
        <div class='next-link'>
        </div>
        <div class='clearfix pad-top'></div>
        <div class='section'>
          <div class='section-header' id='s1'>
            4.1 Two nodes leave, no nodes enter
          </div>
          <div class='section-content'>
            In all previous lessons, we've only added data or modified data.
            Never have we <em>removed</em> data from a loving home.
            Our <a href='lesson_1.html#s6'>introduction of the <code>enter</code> selection</a>
            left a question unspoken - what if one had less data? Would there
            be a corresponding <code>exit</code> selection to match?
            <div class='sample'>
              <code class='block html'>&lt;div class='captain'&gt;Kirk&lt;/div&gt;
&lt;div class='captain'&gt;Picard&lt;/div&gt;
&lt;div class='captain'&gt;Sisko&lt;/div&gt;
&lt;div class='captain'&gt;Janeway&lt;/div&gt;
&lt;div class='captain'&gt;Archer&lt;/div&gt;</code>
              <code class='block js'>var captainNames = [
  'Kirk',
  'Picard',
  'Sisko',
  'Janeway',
  // I never liked Enterprise.
  // 'Archer',
];
var captains = d3.selectAll('.captain').data(captainNames);
<em>captains.exit()
    .remove();</em>
captains
    .text(String);</code>
              <code class='block result'></code>
            </div>
            The <code>remove</code> function, rather obviously, removes the
            selection from the DOM. Its use isn't limited to <code>exit</code>
            selections, but it is most commonly used there. You also need not
            remove the <code>exit</code>ing nodes - there is nothing inherently
            special about the selection and it functions identically to the
            <code>update</code> selection. Except, of course, it has no data:
            <div class='sample'>
              <code class='block html'>&lt;div class='captain'&gt;Kirk&lt;/div&gt;
&lt;div class='captain'&gt;Picard&lt;/div&gt;
&lt;div class='captain'&gt;Sisko&lt;/div&gt;
&lt;div class='captain'&gt;Janeway&lt;/div&gt;
&lt;div class='captain'&gt;Archer&lt;/div&gt;</code>
              <code class='block js'>var captainNames = [
  'Kirk',
  'Picard',
  'Sisko',
  'Janeway',
  // I never liked Enterprise.
  // 'Archer',
];
var captains = d3.selectAll('.captain').data(captainNames);
captains.exit()
    .style('color', 'grey')
    .text(function(d, i) { return 'data: [' + d + '], index: [' + i + ']'; });
captains
    .text(String);</code>
              <code class='block result'></code>
            </div>
            But how, exactly, does d3 decide which nodes are in the exit
            selection? If the data started as <span class='nobr'><code>[0, 2, 4]</code></span>
            and was <code>update</code>-d to <span class='nobr'><code>[2, 4, 6]</code>,</span>
            would any nodes <code>exit</code>? With the tools presented so
            far, <em>no</em>. Just as <code>enter</code> is defined as all the
            new indices with data, <code>exit</code> is all the indices that no
            longer have data. Consequently, we can't have an <code>enter</code>
            and an <code>exit</code> from the same <code>data</code> binding. At
            least, not yet. Consider the following example:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var chart = d3.select('#chart');
chart.selectAll('div')
    .data([0, 2, 4]).enter()
  .append('div')
    .text(String);

var divs = chart.selectAll('div')
    .data([2, 4]);

divs.exit()
    .style('color', 'grey')
    .text('Poor, unloved datum');
divs
    .text(function(d) { return d + ' - still kicking'; });</code>
              <code class='block result'></code>
            </div>
            As expected, the <em>last</em> node is the <code>exit</code>-ing node.
            The mapping from pre-<code>update</code> node to post-<code>update</code>
            node is by index. The node formerly known as <code>0</code> is now
            known as <code>2</code> after the <code>update</code>.
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s2'>
            4.2 A new dawn for data - the key
          </div>
          <div class='section-content'>
            One last bit before animations - key functions. Many of the functions
            we've seen in D3 have additional, optional params. <code>data</code>
            is no exception. In addition to the first argument (to specify the data),
            it accepts a <em>key function</em> as a second argument. What's a key
            for, huh? To unlock doors, of course. Doors to data-binding fun!
            <hr>
            Or, you know, something else. The key function allows one to specify
            a data mapping from pre-<code>update</code> to post-<code>update</code>
            instead of the default by-index behavior. In other words, it defines
            if a datum is exiting, entering, or updating. Consider our previous
            example, but with a key function that defines an identity mapping:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var chart = d3.select('#chart');
<em>var keyFn = function(d) { return d; };</em>
chart.selectAll('div')
    .data([0, 2, 4], <em>keyFn</em>).enter()
  .append('div')
    .text(String);

var divs = chart.selectAll('div')
    .data([2, 4], <em>keyFn</em>);

divs.exit()
    .style('color', 'grey')
    .text('Poor, unloved datum');
divs
    .text(function(d) { return d + ' - still kicking'; });</code>
              <code class='block result'></code>
            </div>
            The function, like most D3 functions, is passed two params:
            <code>data</code> and <code>index</code> along with the <code>this</code>
            bound to the appropriate <code>Element</code>. To pair nodes up with
            data, D3 calls the <code>key</code> function on each selected node
            and on the fresh data. The <code>exit</code> selection is all nodes
            selected with a key not present in the fresh data (in set terms,
            <code>{key(node): node &isin; selected} - {key(datum): datum &isin; data}</code>.
            Likewise, <code>enter</code> is all nodes with keys in fresh data, but not in
            selected and the basic selection is all selected nodes with a matching
            key in data (
            <code>{key(node): node &isin; selected} &cap; {key(datum): datum &isin; data}</code>).
            <hr>
            What does this mean for us? Well, the first node in the tree is now
            grey, not the last. That is about it. We'll find this useful in the
            next section. One last thing to note: the returned key is
            <code>string</code>-ified, so using an <code>Array</code> or <code>
            Object</code> will lead to all data having the same key - not a good
            thing.
            <div class='aside'>
              If you are the kind that likes to cause trouble, find flaws in
              things, or worry about corner cases - have you checked for
              backdoors in your compiler yet? Also, let me head off two
              possible questions. First, the <code>key</code> function only
              matters at the time of calling <code>data</code>, and only for
              that single call. Previous and future calls could use a different
              function. Second, if your key function does not provide a unique
              mapping you are in for a world of hurt - the <code>enter</code> and
              <code>exit</code> sets will be mystifying.
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s3'>
            4.3 Enter-Update-Exit
          </div>
          <div class='section-content'>
            Example code, up until this point, as been a single-run affair - we
            select some nodes, we update attributes on them, and we go on our
            way. What if we wish for our method to be more than a fling? What if
            we want our callers to call us (maybe)?
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum')
      .text(d3.format('.2f'));
};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            What happened? Why doesn't the text update? Shouldn't we get a fresh
            set of five numbers each time <code>renderData</code> is called? No,
            not with this code. Now that our function is called multiple times,
            we must consider when attributes can change and when they can't.
            Shoulde the <code>class</code> of a <code>div</code> in this example
            ever change? Should the <code>text</code> of a <code>div</code>
            change? To answer these questions, consider how the attribute is
            set. If your attribute depends on <code>data</code>, then it can
            change. And attributes that can change should be set on the
            <em>entire</em> selection:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
<em>  // The number changes each time; ensure the text does as well.
  numbers
      .text(d3.format('.2f'));</em>
};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Far out! Now, I've written this code in a very specific order - the
            order from the section title. <code>enter</code> before
            <code>update</code> (our fancy name for operating on the original
            selection). What if we write it in the reverse order? With
            <code>update</code> before <code>enter</code>? Not the nicest:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'><div class='hide'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
</div>  numbers
      .text(d3.format('.2f'));
  numbers.enter().append('div')
      .attr('class', 'datum');
<div class='hide'>};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</div></code>
              <code class='block result'></code>
            </div>
            You may have noticed the first time you made it rain data it did
            not, in fact, rain data. We were instead parched for data. But, if
            you look ever more closely, you'll notice it had still rained
            <code>div</code>s. This should be obvious in retrospect - the code
            first set properties on divs, then added new ones. If we have none
            to begin with, nothing will get updated.
            <div class='aside'>
              d3 does something to make the
              <code>enter</code>-<code>update</code> pattern more effective -
              any nodes appened to an <code>enter</code> are immediately filled
              in on the original selection. By writing your <code>enter</code>
              first, you automatically get any operations from your
              <code>update</code> applied.
            </div>
            So, what of our third musketeer - the <code>exit</code>? An example,
            of course:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var numData = Math.floor(5 * Math.random());
  var data = d3.range(numData).map(Math.random);  // [0-4] random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
  numbers
      .text(d3.format('.2f'));
  numbers.exit()
      .remove();
};
<div class='hide'>root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</div></code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s4'>
            4.4 Animate
          </div>
          <div class='section-content'>
            Drumroll - animation time! Animations in D3 are very simple to
            initiate. And, as is wont for easy tasks, easy to mess up. A
            <code><a href='https://github.com/mbostock/d3/wiki/Selections#wiki-transition'>
            transition</a></code> is just another function called on a selection.
            It takes no arguments and returns a <code><a href='https://github.com/mbostock/d3/wiki/Transitions'>d3.transition</a></code>
            object. You could read all about them by clicking on the link, or
            you could keep reading my tutorial. Maybe both? Wouldn't want to hurt
            mine nor mbostock's feelings, now would you?
            <hr>
            A <code>d3.transition</code> acts just like a
            <code>selection</code> with a few extra methods tacked on, and a
            few other methods removed. The three most important methods are
            retained - <code>attr</code>, <code>style</code>, and <code>text</code>.
            These three will continue as your bread-and-butter of D3. As you may
            have guessed from the identical names, <code>attr</code>, <code>style</code>,
            and <code>text</code> accomplish the same ends, with the same arguments,
            as the <code>d3.selection</code> methods.
            <hr>
            With one difference, of course. Two of the setters
            (<code>attr</code>/<code>style</code>) will not immediately
            take effect, but instead gradually change them from the current
            value to the one specified. Consider our previous example, but with
            animating opacities:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var numData = Math.floor(5 * Math.random());
  var data = d3.range(numData).map(Math.random);  // [0-4] random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
  numbers<em>.transition()</em>
      <em>.style('opacity', Number)</em>
      .text(d3.format('.2f'));
  numbers.exit()
      .remove();
};
root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Nitpicker that I am, two qualms with the example get me. For one,
            watch what happens when a new div is added. They fade from 100%
            opacity to whatever their target value is! That isn't a very good
            visual; why not have them start at 0% and fade in, instead of out?
            The second is the inverse - our exiting nodes simply go poof. Why
            not fade them out into the dark of the night? It sounds like we want
            two changes: new nodes should start with an <code>opacity</code> of
            <code>0</code>, and <code>exit</code>ing nodes should animate to
            <code>0</code> before going away. We can turn that directly into two
            new lines of code, and one modified one (ignore the incorrect
            sizing, it is a defect in my page's code, not that of the example):
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var numData = Math.floor(5 * Math.random());
  var data = d3.range(numData).map(Math.random);  // [0-4] random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      <em>.style('opacity', 0)</em>
      .attr('class', 'datum');
  numbers.transition()
      .style('opacity', Number)
      .text(d3.format('.2f'));
  numbers.exit()<em>.transition()</em>
      <em>.style('opacity', 0)</em>
      .remove();
};
root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Nifty! By giving the <code>enter</code>ing nodes an initial opacity
            of 0, now they fade in to whatever their target may be. And by
            turning our <code>exit</code> call into a <code>transition</code> we
            make the nodes fade out. Of note is the behaviour of a call to
            <code>remove</code> on a transition - it is delayed until the
            transition completes, allowing all to see the majesty of your
            animation before unceremoniously severing the nodes from the
            document. A sad life they lead, sad indeed.
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s5'>
            4.5 An Annotated Animated Example
          </div>
          <div class='section-content'>
            Let's one more example, which could accurately be described as a
            graph:
            <div class='sample'>
              <code class='block html'>&lt;style type='text/css'&gt;
  rect.bar {
    fill: #ccf;
    stroke: #000;
  }
&lt;/style&gt;
&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root');
var w = 300;
var h = 100;
var svg = root.append('svg')
    .attr('width', w)
    .attr('height', h);
<div class='annotate'>
  // We will draw 3-5 bars for random numbers in the range [0, 1), with a small text label afterwards. 30 is, sadly, a magic number - you can expect a few of these in svg.
</div>
var xScale = d3.scale.linear()
    .range([0, w - 30]);  // Allow 30 pixels of space for the labels.
var yScale = d3.scale.linear()<div class='annotate'>
  // Note the <code>domain</code> is constant; this way, the size of a bar is constant whether we have <code>3</code>, <code>4</code>, or <code>5</code>.
    </div>
    .domain([0, 5])
    .range([0, h]);

var renderBars = function() {
  var numData = 3 + Math.floor(Math.random() * 3);  // 3-5 numbers
  var data = d3.range(numData).map(Math.random);    // between [0, 1)<div class='annotate'>
    // <code>enter</code> of the enter-update-exit triumverate.
  </div>
  var bars = svg.selectAll('rect.bar').data(data);
  var newBars = bars.enter().append('rect')
      .attr('class', 'bar')<div class='annotate'>
        // The <code>enter</code> animation is a fade in from 0 opacity combined with a grow to the target width.<hr>Using <code>xScale(0)</code> for the x position makes our code more flexible. If we changed the bars to have an indent of 10px, this code need not change.<hr>The same effect could, of course, be accomplished using a <code>&lt;g&gt;</code> element and modifying its <code>transform</code> property.
      </div>
      .attr('opacity', 0)
      .attr('x', xScale(0))<div class='annotate'>
        // Each bar should get some padding. I arbitrarily decided 20% the height of a bar between each bar - or, 10% from the top and 10% from the bottom.<hr>Or, in other words, each bar should go from <code>yScale(i + 0.1)</code> to <code>yScale(i + 0.9)</code>. The height could also be written as, simply, <code>yScale(0.8)</code> or with constants. It comes down to taste, though I chose this value to call out the duality of the <code>y</code> and <code>height</code> properties. As with the <code>xScale(0)</code> call above, make sure whichever solution looks sexiest to you uses the <code>yScale</code>.
      </div>
      .attr('y', function(d, i) { return yScale(i + 0.1); })
      .attr('height', function(d, i) { return yScale(i + 0.9) - yScale(i + 0.1);});
  bars.transition()<div class='annotate'>
    // <code>update</code> of the enter-update-exit triumverate. One gotcha with the pattern is the behavior of repeated calls to <code>transition</code> on a node - the last one wins.<hr>Even if it looks cleaner to handle the transition from 0 opacity to 1 on the new nodes using the <code>newBars</code> selection, the subsequent <code>transition</code> on <code>bars</code> would override it. Sometimes, an enter animation is distinct enough from the update that separating the two makes sense - in this case, either set up your update transition before appending new nodes, or place the enter transition after the update transition.
      </div>
      .attr('width', xScale)
      .attr('opacity', 1);
  bars.exit().transition()
      .attr('opacity', 0)
      .attr('width', 0)
      .remove();

  var labels = svg.selectAll('text.label').data(data);
  var newLabels = labels.enter().append('text')
      .attr('class', 'label')
      .attr('opacity', 0)
      .attr('x', xScale(0))
      .attr('y', function(d, i) { return yScale(i + 0.5); })
      .attr('dx', '0.3em')
      .attr('dy', '0.4em');
  labels.transition()
      .attr('x', xScale)
      .attr('opacity', 1)
      .text(d3.format('.2f'));
  labels.exit().transition()
      .attr('opacity', 0)
      .attr('x', xScale(0))
      .remove();
};

root.append('br');

root.append('button')
    .text('run renderBars')
    .on('click', renderBars);</code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class='footer'>
      <div class='content'>
        <div class='prev-link'>
          <a href='lesson_3.html'>&laquo; previously: (moderately) advanced data</a>
        </div>
        <div class='next-link'>
        </div>
        <div class='clearfix pad-top'></div>
        Copyright 2012 <a href='http://hazzens.com'>Mikey Levine</a>
        &mdash; <a href='atom.xml'>New Lesson Feed</a>
        <div class='float-right'>
          Built using <a href='http://d3js.org'>D3</a> and
          <a href='https://github.com/einars/js-beautify'>js-beautify</a>
        </div>
      </div>
    </div>
  </body>
  <script type="text/javascript">
    tut.init();
    tut3.init();
  </script>
</html>
