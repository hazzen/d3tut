<html>
  <head>
    <meta charset="utf-8">
    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="Lessons ATOM Feed">
    <link href="reset.css" rel="stylesheet" type="text/css">
    <link href="base.css" rel="stylesheet" type="text/css">
    <title>
      D3, Conceptually - Lesson 4: Changing Data
    </title>
    <script type="text/javascript" src="d3.v2.min.js"></script>
    <script type="text/javascript" src="base.js"></script>
    <script type="text/javascript" src="beautify-html.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-24357809-1']);
      _gaq.push(['_setDomainName', 'hazzens.com']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class='header'>
      <div class='left-bar'>
      </div>
      <div class='content'>
        <h1 id='masthead'>
          D3, Conceptually
        </h1>
        <h2 class='lesson'>
          Lesson 4: Changing Data
        </h2>
        originally published FIX ME
      </div>
    </div>
    <div class='main'>
      <div class='left-bar'>
        <h2 class='border-bottom'>index</h2>
        <ul class='pad-top selector'>
          <li><a href='lesson_0.html'>0. Preface</a></li>
          <li><a href='lesson_1.html'>1. Introductory elements</a></li>
          <li><a href='lesson_2.html'>2. Charts</a></li>
          <li><a href='lesson_3.html'>3. (Moderately) Advanced Data</a></li>
          <li class='selected'><a href='lesson_4.html'>4. Changing Data</a></li>
        </ul>
      </div>
      <div class='content'>
        <div class='prev-link'>
          <a href='lesson_3.html'>&laquo; previously: (moderately) advanced data</a>
        </div>
        <div class='next-link'>
        </div>
        <div class='clearfix pad-top'></div>
        <div class='section'>
          <div class='section-header' id='s1'>
            4.1 Two nodes leave, no nodes enter
          </div>
          <div class='section-content'>
            In all previous lessons, we've only added data or modified data.
            Never have we <em>removed</em> data from a loving home.
            Our <a href='lesson_1.html#s6'>introduction of the <code>enter</code> selection</a>
            left a question unspoken - what if one had less data? Would there
            be a corresponding <code>exit</code> selection to match?
            <div class='sample'>
              <code class='block html'>&lt;div class='captain'&gt;Kirk&lt;/div&gt;
&lt;div class='captain'&gt;Picard&lt;/div&gt;
&lt;div class='captain'&gt;Sisko&lt;/div&gt;
&lt;div class='captain'&gt;Janeway&lt;/div&gt;
&lt;div class='captain'&gt;Archer&lt;/div&gt;</code>
              <code class='block js'>var captainNames = [
  'Kirk',
  'Picard',
  'Sisko',
  'Janeway',
  // I never liked Enterprise.
  // 'Archer',
];
var captains = d3.selectAll('.captain').data(captainNames);
<em>captains.exit()
    .remove();</em>
captains
    .text(String);</code>
              <code class='block result'></code>
            </div>
            The <code>remove</code> function, rather obviously, removes the
            selection from the DOM. Its use isn't limited to <code>exit</code>
            selections, but it is most commonly used there. You also need not
            remove the <code>exit</code>ing nodes - there is nothing inherently
            special about the selection and it functions identically to the
            <code>update</code> selection. Except, of course, it has no data:
            <div class='sample'>
              <code class='block html'>&lt;div class='captain'&gt;Kirk&lt;/div&gt;
&lt;div class='captain'&gt;Picard&lt;/div&gt;
&lt;div class='captain'&gt;Sisko&lt;/div&gt;
&lt;div class='captain'&gt;Janeway&lt;/div&gt;
&lt;div class='captain'&gt;Archer&lt;/div&gt;</code>
              <code class='block js'>var captainNames = [
  'Kirk',
  'Picard',
  'Sisko',
  'Janeway',
  // I never liked Enterprise.
  // 'Archer',
];
var captains = d3.selectAll('.captain').data(captainNames);
captains.exit()
    .style('color', 'grey')
    .text(function(d, i) { return 'data: [' + d + '], index: [' + i + ']'; });
captains
    .text(String);</code>
              <code class='block result'></code>
            </div>
            But how, exactly, does d3 decide which nodes are in the exit
            selection? If the data started as <span class='nobr'><code>[0, 2, 4]</code></span>
            and was <code>update</code>-d to <span class='nobr'><code>[2, 4, 6]</code>,</span>
            would any nodes <code>exit</code>? With the tools presented so
            far, <em>no</em>. Just as <code>enter</code> is defined as all the
            new indices with data, <code>exit</code> is all the indices that no
            longer have data. Consequently, we can't have an <code>enter</code>
            and an <code>exit</code> from the same <code>data</code> binding. At
            least, not yet. Consider the following example:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var chart = d3.select('#chart');
chart.selectAll('div')
    .data([0, 2, 4]).enter()
  .append('div')
    .text(String);

var divs = chart.selectAll('div')
    .data([2, 4]);

divs.exit()
    .style('color', 'grey')
    .text('Poor, unloved datum');
divs
    .text(function(d) { return d + ' - still kicking'; });</code>
              <code class='block result'></code>
            </div>
            As expected, the <em>last</em> node is the <code>exit</code>-ing node.
            The mapping from pre-<code>update</code> node to post-<code>update</code>
            node is by index. The node formerly known as <code>0</code> is now
            known as <code>2</code> after the <code>update</code>.
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s2'>
            4.2 A new dawn for data - the key
          </div>
          <div class='section-content'>
            One last bit before animations - key functions. Many of the functions
            we've seen in D3 have additional, optional params. <code>data</code>
            is no exception. In addition to the first argument (to specify the data),
            it accepts a <em>key function</em> as a second argument. What's a key
            for, huh? To unlock doors, of course. Doors to data-binding fun!
            <hr>
            Or, you know, something else. The key function allows one to specify
            a data mapping from pre-<code>update</code> to post-<code>update</code>
            instead of the default by-index behavior. In other words, it defines
            if a datum is exiting, entering, or updating. Consider our previous
            example, but with a key function that defines an identity mapping:
            <div class='sample'>
              <code class='block html'>&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var chart = d3.select('#chart');
<em>var keyFn = function(d) { return d; };</em>
chart.selectAll('div')
    .data([0, 2, 4], <em>keyFn</em>).enter()
  .append('div')
    .text(String);

var divs = chart.selectAll('div')
    .data([2, 4], <em>keyFn</em>);

divs.exit()
    .style('color', 'grey')
    .text('Poor, unloved datum');
divs
    .text(function(d) { return d + ' - still kicking'; });</code>
              <code class='block result'></code>
            </div>
            The function, like most D3 functions, is passed two params:
            <code>data</code> and <code>index</code> along with the <code>this</code>
            bound to the appropriate <code>Element</code>. To pair nodes up with
            data, D3 calls the <code>key</code> function on each selected node
            and on the fresh data. The <code>exit</code> selection is all nodes
            selected with a key not present in the fresh data (in set terms,
            <code>{key(node): node &isin; selected} - {key(datum): datum &isin; data}</code>.
            Likewise, <code>enter</code> is all nodes with keys in fresh data, but not in
            selected and the basic selection is all selected nodes with a matching
            key in data (
            <code>{key(node): node &isin; selected} &cap; {key(datum): datum &isin; data}</code>).
            <hr>
            What does this mean for us? Well, the first node in the tree is now
            grey, not the last. That is about it. We'll find this useful in the
            next section. One last thing to note: the returned key is
            <code>string</code>-ified, so using an <code>Array</code> or <code>
            Object</code> will lead to all data having the same key - not a good
            thing.
            <div class='aside'>
              If you are the kind that likes to cause trouble, find flaws in
              things, or worry about corner cases - have you checked for
              backdoors in your compiler yet? Also, let me head off two
              possible questions. First, the <code>key</code> function only
              matters at the time of calling <code>data</code>, and only for
              that single call. Previous and future calls could use a different
              function. Second, if your key function does not provide a unique
              mapping you are in for a world of hurt - the <code>enter</code> and
              <code>exit</code> sets will be mystifying.
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s3'>
            4.3 Enter-Update-Exit
          </div>
          <div class='section-content'>
            Example code, up until this point, as been a single-run affair - we
            select some nodes, we update attributes on them, and we go on our
            way. What if we wish for our method to be more than a fling? What if
            we want our callers to call us (maybe)?
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum')
      .text(d3.format('.2f'));
};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            What happened? Why doesn't the text update? Shouldn't we get a fresh
            set of five numbers each time <code>renderData</code> is called? No,
            not with this code. Now that our function is called multiple times,
            we must consider when attributes can change and when they can't.
            Shoulde the <code>class</code> of a <code>div</code> in this example
            ever change? Should the <code>text</code> of a <code>div</code>
            change? To answer these questions, consider how the attribute is
            set. If your attribute depends on <code>data</code>, then it can
            change. And attributes that can change should be set on the
            <em>entire</em> selection:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
<em>  // The number changes each time; ensure the text does as well.
  numbers
      .text(d3.format('.2f'));</em>
};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Far out! Now, I've written this code in a very specific order - the
            order from the section title. <code>enter</code> before
            <code>update</code> (our fancy name for operating on the original
            selection). What if we write it in the reverse order? With
            <code>update</code> before <code>enter</code>? Not the nicest:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'><div class='hide'>var root = d3.select('#root')

var renderData = function() {
  var data = d3.range(5).map(Math.random);  // 5 random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
</div>  numbers
      .text(d3.format('.2f'));
  numbers.enter().append('div')
      .attr('class', 'datum');
<div class='hide'>};

root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</div></code>
              <code class='block result'></code>
            </div>
            You may have noticed the first time you made it rain data it did
            not, in fact, rain data. We were instead parched for data. But, if
            you look ever more closely, you'll notice it had still rained
            <code>div</code>s. This should be obvious in retrospect - the code
            first set properties on divs, then added new ones. If we have none
            to begin with, nothing will get updated.
            <div class='aside'>
              d3 does something to make the
              <code>enter</code>-<code>update</code> pattern more effective -
              any nodes appened to an <code>enter</code> are immediately filled
              in on the original selection. By writing your <code>enter</code>
              first, you automatically get any operations from your
              <code>update</code> applied.
            </div>
            So, what of our third musketeer - the <code>exit</code>? An example,
            of course:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var numData = Math.floor(5 * Math.random());
  var data = d3.range(numData).map(Math.random);  // [0-4] random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
  numbers
      .text(d3.format('.2f'));
  numbers.exit()
      .remove();
};
<div class='hide'>root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</div></code>
              <code class='block result'></code>
            </div>
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s4'>
            4.4 Animate
          </div>
          <div class='section-content'>
            Drumroll - animation time! Animations in D3 are very simple to
            initiate. And, as is wont for easy tasks, easy to mess up. A
            <code><a href='https://github.com/mbostock/d3/wiki/Selections#wiki-transition'>
            transition</a></code> is just another function called on a selection.
            It takes no arguments and returns a <code><a href='https://github.com/mbostock/d3/wiki/Transitions'>d3.transition</a></code>
            object. You could read all about them by clicking on the link, or
            you could keep reading my tutorial. Maybe both? Wouldn't want to hurt
            mine nor mbostock's feelings, now would you?
            <hr>
            A <code>d3.transition</code> acts just like a
            <code>selection</code> with a few extra methods tacked on, and a
            few other methods removed. The three most important methods are
            retained - <code>attr</code>, <code>style</code>, and <code>text</code>.
            These three will continue as your bread-and-butter of D3. As you may
            have guessed from the identical names, <code>attr</code>, <code>style</code>,
            and <code>text</code> accomplish the same ends, with the same arguments,
            as the <code>d3.selection</code> methods.
            <hr>
            With one difference, of course. Two of the setters
            (<code>attr</code>/<code>style</code>) will not immediately
            take effect, but instead gradually change them from the current
            value to the one specified. Consider our previous example, but with
            animating opacities:
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var numData = Math.floor(5 * Math.random());
  var data = d3.range(numData).map(Math.random);  // [0-4] random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      .attr('class', 'datum');
  numbers<em>.transition()</em>
      <em>.style('opacity', Number)</em>
      .text(d3.format('.2f'));
  numbers.exit()
      .remove();
};
root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Nitpicker that I am, two qualms with the example get me. For one,
            watch what happens when a new div is added. They fade from 100%
            opacity to whatever their target value is! That isn't a very good
            visual; why not have them start at 0% and fade in, instead of out?
            The second is the inverse - our exiting nodes simply go poof. Why
            not fade them out into the dark of the night? It sounds like we want
            two changes: new nodes should start with an <code>opacity</code> of
            <code>0</code>, and <code>exit</code>ing nodes should animate to
            <code>0</code> before going away. We can turn that directly into two
            new lines of code, and one modified one (ignore the incorrect
            sizing, it is a defect in my page's code, not that of the example):
            <div class='sample'>
              <code class='block html'>&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root')

var renderData = function() {
  var numData = Math.floor(5 * Math.random());
  var data = d3.range(numData).map(Math.random);  // [0-4] random numbers [0, 1)
  var numbers = root.selectAll('div.datum').data(data);
  numbers.enter().append('div')
      <em>.style('opacity', 0)</em>
      .attr('class', 'datum');
  numbers.transition()
      .style('opacity', Number)
      .text(d3.format('.2f'));
  numbers.exit()<em>.transition()</em>
      <em>.style('opacity', 0)</em>
      .remove();
};
root.append('button')
    .text('make it rain data!')
    .on('click', renderData);</code>
              <code class='block result'></code>
            </div>
            Nifty! By giving the <code>enter</code>ing nodes an initial opacity
            of 0, now they fade in to whatever their target may be. And by
            turning our <code>exit</code> call into a <code>transition</code> we
            make the nodes fade out. Of note is the behaviour of a call to
            <code>remove</code> on a transition - it is delayed until the
            transition completes, allowing all to see the majesty of your
            animation before unceremoniously severing the nodes from the
            document. A sad life they lead, sad indeed.
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s5'>
            4.5 An Annotated Animated Example
          </div>
          <div class='section-content'>
            Let's one more example, which could accurately be described as a
            graph:
            <div class='sample'>
              <code class='block html'>&lt;style type='text/css'&gt;
  rect.bar {
    fill: #ccf;
    stroke: #000;
  }
&lt;/style&gt;
&lt;div id='root'&gt;&lt;/div&gt;</code>
              <code class='block js'>var root = d3.select('#root');
var w = 300;
var h = 100;
var svg = root.append('svg')
    .style('display', 'block')
    .attr('width', w)
    .attr('height', h);
<div class='annotate'>
  /* We will draw 3-5 bars for random numbers in the range [0, 1), with a small
  text label afterwards. 30 is, sadly, a magic number - you can expect a few of
  these in svg. */
</div>var xScale = d3.scale.linear()
    .range([0, w - 30]);  // Allow 30 pixels of space for the labels.
var yScale = d3.scale.linear()<div class='annotate'>
  /* Note the <code>domain</code> is constant; this way, the size of a bar is
  constant whether we have <code>3</code>, <code>4</code>, or <code>5</code>.
  */
</div>    .domain([0, 5])
    .range([0, h]);

var renderBars = function() {
  var numData = 3 + Math.floor(Math.random() * 3);  // 3-5 numbers
  var data = d3.range(numData).map(Math.random);    // between [0, 1)<div class='annotate'>
    /* <code>enter</code> of the enter-update-exit triumverate. Keep in mind
    this selection will have initial <code>attr</code>s as well as
    <code>transition</code>. If an <code>attr</code> never changes - like the
    <code>class</code> of a bar - set it on newly-created <code>enter</code>
    nodes. */
</div>  var bars = svg.selectAll('rect.bar').data(data);
  var newBars = bars.enter().append('rect')
      .attr('class', 'bar')<div class='annotate'>
        /* The <code>enter</code> animation is a fade in from 0 opacity
        combined with a grow to the target width.<hr>Using
        <code>xScale(0)</code> for the x position makes our code more flexible.
        If we changed the bars to have an indent of 10px, this code need not
        change.<hr>The same effect could, of course, be accomplished using a
        <code>&lt;g&gt;</code> element and modifying its <code>transform</code>
        property. */
</div>      .attr('opacity', 0)
      .attr('x', xScale(0))<div class='annotate'>
        /* Each bar should get some padding. I arbitrarily decided 20% the
        height of a bar between each bar - or, 10% from the top and 10% from
        the bottom.<hr>Or, in other words, each bar should go from
        <code>yScale(i + 0.1)</code> to <code>yScale(i + 0.9)</code>. The
        height could also be written as, simply, <code>yScale(0.8)</code> or
        with constants. It comes down to taste, though I chose this value to
        call out the duality of the <code>y</code> and <code>height</code>
        properties. As with the <code>xScale(0)</code> call above, make sure
        whichever solution looks sexiest to you uses the <code>yScale</code>.
        */
</div>      .attr('y', function(d, i) { return yScale(i + 0.1); })
      .attr('height', function(d, i) { return yScale(i + 0.9) - yScale(i + 0.1);});
  bars.transition()<div class='annotate'>
    /* <code>update</code> of the enter-update-exit triumverate. One gotcha
    with the pattern is the behavior of repeated calls to
    <code>transition</code> on a node - the last one wins.<hr>Even if it looks
    cleaner to handle the transition from 0 opacity to 1 on the new nodes using
    the <code>newBars</code> selection, the subsequent <code>transition</code>
    on <code>bars</code> would override it. Sometimes, an enter animation is
    distinct enough from the update that separating the two makes sense - in
    this case, either set up your update transition before appending new nodes,
    or place the enter transition after the update transition.
    */
</div>      .attr('width', xScale)
      .attr('opacity', 1);
    bars.exit().transition()<div class='annotate'>
      /* <code>exit</code> of the enter-update-exit triumverate. We are
      initiating a <code>transition</code>, so the <code>remove</code> call
      won't happen until the animation has ended. */
</div>      .attr('opacity', 0)
      .attr('width', 0)
      .remove();

  var labels = svg.selectAll('text.label').data(data);
  var newLabels = labels.enter().append('text')
      .attr('class', 'label')<div class='annotate'>
        /* We go through the same <code>opacity</code> hoops as on the bars with
        our text. In fact, much of the animation is the same so that text and
        bars appear a single unit. */
</div>      .attr('opacity', 0)
      .attr('x', xScale(0))
      .attr('y', function(d, i) { return yScale(i + 0.5); })<div class='annotate'>
        /* <code>0.3em</code> is a magic number that looks good, giving just
        enough padding. Pixels would be a fine measure as well - five of them or
        so. */
</div>      .attr('dx', '0.3em')<div class='annotate'>
        /* <code>0.35em</code> is SVG for <code>vertical-align: center</code>
        - not technically true, but true enough. */
</div>      .attr('dy', '0.35em');
  labels.transition()
      .attr('x', xScale)
      .attr('opacity', 1)<div class='annotate'>
        /* The <code>d3.format</code> <a
          href='https://github.com/mbostock/d3/wiki/Formatting#wiki-d3_format'>mini-language</a>
        is very rich and familiar to users of Python, and ever-so-slightly
        confusing to those accustomed to <code>printf</code>. You can just yell
        at me to get off your lawn, really. */
</div>      .text(d3.format('.2f'));
  labels.exit().transition()
      .attr('opacity', 0)
      .attr('x', xScale(0))
      .remove();
};

root.append('button')
    .text('run renderBars')
    .on('click', renderBars);</code>
              <code class='block result'></code>
            </div>
            Now go off and animate some bars! But one more thing, and it is
            dreadfully important: object constancy. A mouthful, truly.
          </div>
        </div>
        <div class='section'>
          <div class='section-header' id='s6'>
            4.6 Constancy, my dear, would you fetch my keys?
          </div>
          <div class='section-content'>
            So: what is object constancy and why should you care? Pretend, for
            a moment, you are playing catch with a parental figure. You are a
            kid. You like catch. Your parental figure tosses a ball your way;
            you see it pause as it leaves their hand. Then, it dissappears and a
            ball materializes in your glove. That ball? No constancy. It jumped
            from parental figure's windup to your waiting glove, and you are
            confused. Is it even the same ball? You didn't see it travel, so you
            can't be sure. You go and lie down, never to play catch again.
            <hr>
            Maybe a graph will help:
            <div class='sample hide-src'>
              <code class='block html'>&lt;style type='text/css'&gt;
  #chart {
    background-color: #fff;
  }
  svg {
    display: block;
    margin-bottom: 10px;
  }
  .highs line {
    stroke-width: 2px;
    stroke: #f88;
  }
  .rains line {
    stroke-width: 2px;
    stroke: #88f;
  }
  text {
    font-size: 13px;
    font-family: sans-serif;
  }
  text.small {
    font-size: 10px;
    fill: #666;
  }
&lt;/style&gt;
&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'>var w = 300;
var h = 220;

var data = [
  {'i':  0,'month': 'January',   'high': 47, 'rain': 5.6},
  {'i':  1,'month': 'February',  'high': 50, 'rain': 3.5},
  {'i':  2,'month': 'March',     'high': 53, 'rain': 3.7},
  {'i':  3,'month': 'April',     'high': 58, 'rain': 2.7},
  {'i':  4,'month': 'May',       'high': 64, 'rain': 1.9},
  {'i':  5,'month': 'June',      'high': 70, 'rain': 1.6},
  {'i':  6,'month': 'July',      'high': 76, 'rain': 0.7},
  {'i':  7,'month': 'August',    'high': 76, 'rain': 0.9},
  {'i':  8,'month': 'September', 'high': 70, 'rain': 1.5},
  {'i':  9,'month': 'October',   'high': 59, 'rain': 3.5},
  {'i': 10,'month': 'November',  'high': 51, 'rain': 6.6},
  {'i': 11,'month': 'December',  'high': 45, 'rain': 5.4},
];
var dataMonth = function(d) { return d['month']; };
var dataHigh = function(d) { return d['high']; };
var dataRain = function(d) { return d['rain']; };
var highScale = d3.scale.linear()
    .domain(d3.extent(data, dataHigh))
    .range([100, 0]);
var rainScale = d3.scale.linear()
    .domain([0, d3.max(data, dataRain)])
    .range([50, 0]);
var xScale = d3.scale.linear()
    .domain([0, data.length])
    .range([0, w]);
var datumWidth = xScale(1) - xScale(0);

var chart = d3.select('#chart').append('svg')
    .attr('width', w)
    .attr('height', h);
var highG = chart.append('g').attr('class', 'highs')
    .attr('transform', 'translate(0, 20)');
var rainG = chart.append('g').attr('class', 'rains')
    .attr('transform', 'translate(' + [0, 30 + d3.max(highScale.range())] + ')');

var title = chart.append('text')
    .attr('x', w / 2)
    .attr('y', h - 10)
    .attr('text-anchor', 'middle')
    .text('Seattle Climate');
var dataLink = chart.append('a')
    .attr('xlink:href', 'http://en.wikipedia.org/wiki/Seattle');
dataLink.append('text')
    .attr('class', 'small')
    .attr('x', w / 2)
    .attr('y', h)
    .attr('text-anchor', 'middle')
    .text('[source]');

var drawChart = function() {
  var highGs = highG.selectAll('g.tick').data(data);
  var newHighGs = highGs.enter().append('g')
      .attr('class', 'tick');
  highGs.transition().duration(1000)
      .attr('transform', function(d, i) {
        return 'translate(' + [xScale(i) + datumWidth / 2, highScale(dataHigh(d))] + ')';
      })
  newHighGs.append('line')
      .attr('x1', -datumWidth / 2)
      .attr('x2', datumWidth / 2);
  newHighGs.append('text')
      .attr('class', 'small')
      .attr('text-anchor', 'middle')
      .attr('dy', '-0.3em');
  highGs.select('text')
      .text(function(d) { return dataHigh(d) + '°F'; });
    
  var rainGs = rainG.selectAll('g.tick').data(data);
  var newRainGs = rainGs.enter().append('g')
      .attr('class', 'tick');
  rainGs.transition().duration(1000)
      .attr('transform', function(d, i) {
        return 'translate(' + [xScale(i) + datumWidth / 2, rainScale(dataRain(d))] + ')';
      })
  newRainGs.append('line')
      .attr('x1', -datumWidth / 2)
      .attr('x2', datumWidth / 2);
  newRainGs.append('text')
      .attr('class', 'small')
      .attr('text-anchor', 'middle')
      .attr('dy', '-0.3em');
  rainGs.select('text')
      .text(function(d) { return dataRain(d) + '"'; });

  var labels = chart.selectAll('text.month').data(data);
  labels.enter().append('text')
      .attr('class', 'month small')
      .attr('y', h - 25)
      .attr('text-anchor', 'middle');
  labels.transition().duration(1000)
      .attr('x', function(d, i) { return xScale(i) + datumWidth / 2; })
      .text(function(d) { return dataMonth(d).substr(0, 3); });
};
drawChart();
var makeSortButton = function(field, rev) {
  return d3.select('#chart').append('button')
      .on('click', function() {
        data.sort(function(a, b) { return rev * (a[field] - b[field]); });
        drawChart();
      });
};
makeSortButton('i', 1).text('Sort by month');
makeSortButton('high', -1).text('Sort by high temperature');
makeSortButton('rain', -1).text('Sort by precipitation');
</code>
              <code class='block result'></code>
            </div>
            When the sorting is changed on the chart, you may see a smooth
            transition. Try, however, tracking a single month - like May (a good
            month, May). It is easy to track when swapping between month and
            temperature, but not so much by precipitation. It jumps, instantly,
            somewhere else on the chart. With object constancy, however:
            <div class='sample hide-src'>
              <code class='block html'>&lt;style type='text/css'&gt;
  #chart {
    background-color: #fff;
  }
  svg {
    display: block;
    margin-bottom: 10px;
  }
  .highs line {
    stroke-width: 2px;
    stroke: #f88;
  }
  .rains line {
    stroke-width: 2px;
    stroke: #88f;
  }
  text {
    font-size: 13px;
    font-family: sans-serif;
  }
  text.small {
    font-size: 10px;
    fill: #666;
  }
&lt;/style&gt;
&lt;div id='chart'&gt;&lt;/div&gt;</code>
              <code class='block js'><div class='hide'>var w = 300;
var h = 220;

var data = [
  {'i':  0,'month': 'January',   'high': 47, 'rain': 5.6},
  {'i':  1,'month': 'February',  'high': 50, 'rain': 3.5},
  {'i':  2,'month': 'March',     'high': 53, 'rain': 3.7},
  {'i':  3,'month': 'April',     'high': 58, 'rain': 2.7},
  {'i':  4,'month': 'May',       'high': 64, 'rain': 1.9},
  {'i':  5,'month': 'June',      'high': 70, 'rain': 1.6},
  {'i':  6,'month': 'July',      'high': 76, 'rain': 0.7},
  {'i':  7,'month': 'August',    'high': 76, 'rain': 0.9},
  {'i':  8,'month': 'September', 'high': 70, 'rain': 1.5},
  {'i':  9,'month': 'October',   'high': 59, 'rain': 3.5},
  {'i': 10,'month': 'November',  'high': 51, 'rain': 6.6},
  {'i': 11,'month': 'December',  'high': 45, 'rain': 5.4},
];
</div>var dataMonth = function(d) { return d['month']; };
var dataHigh = function(d) { return d['high']; };
var dataRain = function(d) { return d['rain']; };
<em>var keyFn = dataMonth;</em>
<div class='hide'>var highScale = d3.scale.linear()
    .domain(d3.extent(data, dataHigh))
    .range([100, 0]);
var rainScale = d3.scale.linear()
    .domain([0, d3.max(data, dataRain)])
    .range([50, 0]);
var xScale = d3.scale.linear()
    .domain([0, data.length])
    .range([0, w]);
var datumWidth = xScale(1) - xScale(0);

var chart = d3.select('#chart').append('svg')
    .attr('width', w)
    .attr('height', h);
var highG = chart.append('g').attr('class', 'highs')
    .attr('transform', 'translate(0, 20)');
var rainG = chart.append('g').attr('class', 'rains')
    .attr('transform', 'translate(' + [0, 30 + d3.max(highScale.range())] + ')');

var title = chart.append('text')
    .attr('x', w / 2)
    .attr('y', h - 10)
    .attr('text-anchor', 'middle')
    .text('Seattle Climate');
var dataLink = chart.append('a')
    .attr('xlink:href', 'http://en.wikipedia.org/wiki/Seattle');
dataLink.append('text')
    .attr('class', 'small')
    .attr('x', w / 2)
    .attr('y', h)
    .attr('text-anchor', 'middle')
    .text('[source]');

</div>var drawChart = function() {
  var highGs = highG.selectAll('g.tick').data(data, <em>keyFn</em>);
<div class='hide'>  var newHighGs = highGs.enter().append('g')
      .attr('class', 'tick');
  highGs.transition().duration(1000)
      .attr('transform', function(d, i) {
        return 'translate(' + [xScale(i) + datumWidth / 2, highScale(dataHigh(d))] + ')';
      })
  newHighGs.append('line')
      .attr('x1', -datumWidth / 2)
      .attr('x2', datumWidth / 2);
  newHighGs.append('text')
      .attr('class', 'small')
      .attr('text-anchor', 'middle')
      .attr('dy', '-0.3em');
  highGs.select('text')
      .text(function(d) { return dataHigh(d) + '°F'; });
</div>  var rainGs = rainG.selectAll('g.tick').data(data, <em>keyFn</em>);
<div class='hide'>  var newRainGs = rainGs.enter().append('g')
      .attr('class', 'tick');
  rainGs.transition().duration(1000)
      .attr('transform', function(d, i) {
        return 'translate(' + [xScale(i) + datumWidth / 2, rainScale(dataRain(d))] + ')';
      })
  newRainGs.append('line')
      .attr('x1', -datumWidth / 2)
      .attr('x2', datumWidth / 2);
  newRainGs.append('text')
      .attr('class', 'small')
      .attr('text-anchor', 'middle')
      .attr('dy', '-0.3em');
  rainGs.select('text')
      .text(function(d) { return dataRain(d) + '"'; });
</div>  var labels = chart.selectAll('text.month').data(data, <em>keyFn</em>);
<div class='hide'>  labels.enter().append('text')
      .attr('class', 'month small')
      .attr('y', h - 25)
      .attr('text-anchor', 'middle');
  labels.transition().duration(1000)
      .attr('x', function(d, i) { return xScale(i) + datumWidth / 2; })
      .text(function(d) { return dataMonth(d).substr(0, 3); });
</div>};
<div class='hide'>drawChart();
var makeSortButton = function(field, rev) {
  return d3.select('#chart').append('button')
      .on('click', function() {
        data.sort(function(a, b) { return rev * (a[field] - b[field]); });
        drawChart();
      });
};
makeSortButton('i', 1).text('Sort by month');
makeSortButton('high', -1).text('Sort by high temperature');
makeSortButton('rain', -1).text('Sort by precipitation');</div></code>
              <code class='block result'></code>
            </div>
            Watch those bars fly! Or, rather, float - the animation has been
            slowed considerably for illustrative purposes only. Now the eye can
            track the data as it changes. You can see when a month doesn't
            change its position; you can see when a month goes from the best to
            the worst. You can also spam clicks on the buttons for fun effects,
            if your <a href='...'>APM</a> is a bit low.
            <hr>
            That must have been hard, write? The code surely changed a great
            deal. Not so! Go ahead, click the "Show code" button. One line
            added, three lines modified. Not bad, not bad.
            <div class='aside'>
              The DOM structure of this chart was chosen arbitrarily - it
              consists of an SVG. Each month has a "g" element for the
              temperature and a "g" element for the rainfall, transformed to the
              approriate x/y position. The month labels are positioned using
              their <code>x</code> property along the bottom. Why this? Why not
              position everything using <code>x</code> and <code>y</code>
              values?
              <hr>
              We net a few benefits from <code>transform</code>-ed
              <code>g</code>s - the children elements are simply positioned -
              all temperature lines receive the same values and need never
              change. Positioning is easier to reason. Given a pen at the
              relevant x/y for a month's temperature, where do we write the
              label? Well, right there (with a little offset so it doesn't
              overlap the line).
              <hr>
              One could also structure the DOM so each month has a
              <code>g</code> element transformed to have the appropriate
              <code>x</code> value, then <code>y</code>-translated
              <code>g</code>s for each of the temperature, rainfall, and month
              labels. Is this better? Maybe; I'm not one to judge. Both work and
              both are flexible.
            </div>
            <hr>
            To read more on object constancy, consider
            <a href='http://bost.ocks.org/mike/constancy/'>mbostock's
              tutorial</a>. It provides a different example which you may find
            more compelling. That wrap up this lesson - you have enough
            knowledge (and enough code samples) to do some serious work.
          </div>
        </div>
      </div>
    </div>
    <div class='footer'>
      <div class='content'>
        <div class='prev-link'>
          <a href='lesson_3.html'>&laquo; previously: (moderately) advanced data</a>
        </div>
        <div class='next-link'>
        </div>
        <div class='clearfix pad-top'></div>
        Copyright 2012 <a href='http://hazzens.com'>Mikey Levine</a>
        &mdash; <a href='atom.xml'>New Lesson Feed</a>
        <div class='float-right'>
          Built using <a href='http://d3js.org'>D3</a> and
          <a href='https://github.com/einars/js-beautify'>js-beautify</a>
        </div>
      </div>
    </div>
  </body>
  <script type="text/javascript">
    tut.init();
  </script>
</html>
